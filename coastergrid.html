<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CoasterGrid - A Coaster Statistics Game</title>
  <meta name="description" content="A roller coaster statistic game.">
  <link rel="stylesheet" type="text/css" href="mainpage.css">
  <link rel="icon" type="image/x-icon" href="/images/FaviconGame2.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      background: #f5f5f5;
      margin: 0;
      padding: 20px;
    }

    .grid-container {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(4, 1fr);
      gap: 5px;
      margin: 20px auto;
      width: 80vw;
      max-width: 600px;
    }

    .cell {
      border: 1px solid #ccc;
      padding: 10px;
      min-height: 60px;
      background: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 14px;
    }

    .header {
      font-weight: bold;
      background-color: #e0e0e0;
    }

    .input-cell {
      cursor: pointer;
    }

    .input-cell:hover {
      background: #f0f0f0;
    }

    .filled-cell {
      background-color: #e6f7ff;
    }

    .park-name {
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }

    .correct {
      background-color: #b7eb8f;
    }

    .incorrect {
      background-color: #ffccc7;
    }

    /* Search Modal Styles */
    .search-modal {
      display: none;
      position: fixed;
      z-index: 100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
    }

    .search-content {
      background-color: white;
      margin: 10% auto;
      padding: 20px;
      border-radius: 8px;
      width: 80%;
      max-width: 500px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .search-container {
      position: relative;
      width: 100%;
    }

    #coasterSearchBox {
      width: 100%;
      padding: 12px;
      font-size: 16px;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
      margin-bottom: 10px;
    }

    .search-list {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
    }

    .search-list .search-item {
      padding: 10px;
      cursor: pointer;
      text-align: left;
      border-bottom: 1px solid #eee;
    }

    .search-list .search-item:hover {
      background-color: #f0f0f0;
    }

    .hide-search-list {
      display: none;
    }

    .search-item-details {
      font-size: 0.8em;
      color: #666;
    }

    .selected-coaster {
      background-color: #e6f7ff;
      border-left: 3px solid #1890ff;
    }

    .modal-buttons {
      margin-top: 15px;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .modal-button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .cancel-button {
      background-color: #f5f5f5;
      color: #333;
    }

    .select-button {
      background-color: #1890ff;
      color: white;
    }

    .select-button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }

    .game-controls {
      margin: 20px auto;
      display: flex;
      justify-content: center;
      gap: 10px;
    }

    .game-button {
      padding: 10px 20px;
      background-color: #1890ff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .game-button:hover {
      background-color: #40a9ff;
    }

    .game-button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }

    .check-results {
      margin-top: 20px;
      padding: 10px;
      border-radius: 4px;
      display: none;
    }

    .success {
      background-color: #f6ffed;
      border: 1px solid #b7eb8f;
      color: #52c41a;
    }

    .failure {
      background-color: #fff2f0;
      border: 1px solid #ffccc7;
      color: #ff4d4f;
    }

    .loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 200px;
    }

    .loading-spinner {
      border: 6px solid #f3f3f3;
      border-top: 6px solid #3498db;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    .criteria-info {
      font-size: 12px;
      margin-top: 5px;
      color: #666;
    }

    .rcdb-link {
      display: inline-block;
      margin-top: 8px;
      padding: 3px 8px;
      background-color: #1890ff;
      color: white;
      border-radius: 4px;
      text-decoration: none;
      font-size: 11px;
      transition: background-color 0.2s;
    }

    .rcdb-link:hover {
      background-color: #40a9ff;
      text-decoration: none;
    }

    .unit-toggle {
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 10px 0;
    }

    .switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 34px;
      margin-right: 10px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 26px;
      width: 26px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
    }

    input:checked+.slider {
      background-color: #2196F3;
    }

    input:focus+.slider {
      box-shadow: 0 0 1px #2196F3;
    }

    input:checked+.slider:before {
      transform: translateX(26px);
    }

    .slider.round {
      border-radius: 34px;
    }

    .slider.round:before {
      border-radius: 50%;
    }

    .stats-info {
      font-size: 11px;
      color: #666;
      margin-top: 3px;
    }

    .unguessed .cell-content {
      background-color: rgba(204, 229, 255, 0.85);
    }

    #settingsButton,
    #infoButton,
    #homeButton {
      position: fixed;
      top: 10px;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 15px;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      z-index: 5;
      font-size: 1.5em;
    }

    #settingsButton {
      right: 10px;
    }

    #infoButton {
      right: 70px;
    }

    #homeButton {
      left: 10px;
    }

    #settingsButton:hover,
    #infoButton:hover,
    #homeButton:hover {
      background-color: white;
      color: black;
    }

    #settingsButton:active,
    #infoButton:active,
    #homeButton:active {
      background-color: white;
      color: black;
    }

    #closeButton {
      color: gray;
      background-color: white;
      z-index: 6;
      padding: 10px;
      cursor: pointer;
      border: none;
      border-radius: 100%;
      transition-duration: 0.2s;
      position: absolute;
      top: 20px;
      right: 20px;
    }

    #closeButton:hover {
      background-color: lightgrey;
    }

    .popupPanel {
      text-align: left;
      color: black;
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: white;
      padding: 20px;
      border-radius: 12px;
      z-index: 10;
      font-family: sans-serif;
    }

    #overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.25);
      /* semi-transparent black */
      z-index: 5;
      /* Behind panels, above background */
    }

    .solution-view {
      background-color: #cccccc;
      /* Light gray */
    }

    .flip-button {
      all: unset;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      width: 30px;
      height: 30px;
      font-size: 18px;
      cursor: pointer;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .loading-spinner-small {
      border: 3px solid #f3f3f3;
      border-top: 3px solid #1890ff;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>
  <!-- Buttons (Top Right/Left) -->
  <button id="homeButton" onclick="window.location.href='index.html'" title="Home Page"><i
      class="fa-solid fa-house-chimney"></i></button>
  <button id="infoButton" onclick="toggleInfoPanel()" title="Info"><i class="fas fa-info-circle"></i></button>
  <button id="settingsButton" onclick="toggleSettingsPanel()" title="Settings"><i class="fas fa-cog"></i></button>

  <div id="overlay"></div>

  <!-- Settings Panel -->
  <div id="settingsPanel" class="popupPanel">
    <h3>Game Settings</h3>
    <p>Game settings coming soon! (including metric conversions)</p>
    <h2 id="puzzleNumberDisplay" style="margin-top: 0; font-weight: normal; color: lightgray; display: none;"></h2>
    <button id="closeButton" onclick="toggleSettingsPanel()">âœ–</button>
  </div>

  <!-- Info Panel -->
  <div id="infoPanel" class="popupPanel">
    <h3>How to Play</h3>
    <p>Fill the grid with roller coasters that match the criteria for both the row and column!<br>
      Add a coaster by clicking on a square, searching for a coaster, and then selecting it!<br>
      The same coaster can only appear on the grid at most one time.<br>
      There is a new puzzle every day (at midnight EST), or you can play in random mode for unlimited puzzles!</p>
    <h3>About the Project</h3>
    <p>This game was coded fully in html, css, and javascript as a personal project.</p>
    <p>If you like this game please check out my <a href="https://www.instagram.com/roller.coaster.images/"
        target="_blank" rel="noopener noreferrer">Roller Coaster Instagram</a>!</p>
    <p>The code for the project can be found on the <a
        href="https://github.com/Watkin81/watkin81.github.io/blob/main/coastergrid.html" target="_blank"
        rel="noopener noreferrer">Watkin81 GitHub</a>!</p>
    <button id="closeButton" onclick="toggleInfoPanel()">âœ–</button>
  </div>

  <h1>Coaster Grid</h1>
  <p>I will do site decoration and formatting later lol</p>

  <div class="game-controls">
    <button class="game-button" id="newGameBtn">New Game</button>
    <button class="game-button" id="endGameBtn">End Game</button>
  </div>

  <div id="loadingContainer" class="loading">
    <div class="loading-spinner"></div>
    <div>Loading coaster data...</div>
  </div>

  <div class="grid-container" id="coasterGrid" style="display: none;">
    <!-- Grid will be generated dynamically -->
  </div>

  <div id="resultsMessage" class="check-results"></div>

  <!-- Search Modal -->
  <div id="searchModal" class="search-modal">
    <div class="search-content">
      <h2>Select a Coaster...</h2>
      <div class="search-container" style="position: relative;">
        <input type="text" id="coasterSearchBox" placeholder="Type coaster name...">
        <div id="searchLoading" style="display: none; position: absolute; top: 12px; right: 16px;">
          <div class="loading-spinner-small"></div>
        </div>
        <div class="search-list hide-search-list" id="searchList">
          <!-- Search results will be added here -->
        </div>
      </div>
      <div class="modal-buttons">
        <button class="modal-button cancel-button" onclick="closeSearchModal()">Cancel</button>
        <button class="modal-button select-button" id="selectButton" disabled>Select</button>
      </div>
    </div>
  </div>

  <script>
    const unitToggleHTML = `
      <div class="unit-toggle">
        <label class="switch">
          <input type="checkbox" id="unitToggle">
          <span class="slider round"></span>
        </label>
        <span id="unitLabel">Imperial Units</span>
      </div>
    `;

    // Game variables
    let useMetricUnits = false;
    let currentCell = null;
    let debounce = null;
    let selectedCoaster = null;
    let gameGrid = [];
    let solution = [];
    let rowCriteria = [];
    let colCriteria = [];
    let allCoasters = [];
    let usedCoasterIds = new Set();
    let gameEnded = false;

    // Global variables to track units and values
    let metricCriteriaValues = {
      height: [],
      length: [],
      speed: []
    };

    let imperialCriteriaValues = {
      height: [],
      length: [],
      speed: []
    };


    // DOM elements
    const searchModal = document.getElementById('searchModal');
    const coasterSearchBox = document.getElementById('coasterSearchBox');
    const searchList = document.getElementById('searchList');
    const selectButton = document.getElementById('selectButton');
    const coasterGrid = document.getElementById('coasterGrid');
    const newGameBtn = document.getElementById('newGameBtn');
    const endGameBtn = document.getElementById('endGameBtn');
    const resultsMessage = document.getElementById('resultsMessage');
    const loadingContainer = document.getElementById('loadingContainer');

    const updatedCellStyles = `
  .grid-container {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);
    gap: 8px; 
    margin: 20px auto; 
    width: 90vw; 
    max-width: 800px; /* Increased from 600px */
  }
  .cell {
    border: 1px solid #ccc; 
    padding: 15px; /* Increased from 10px */
    min-height: 100px; /* Increased from 60px */
    background: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    font-size: 14px;
    position: relative;
  }
  .cell-content {
    position: relative;
    z-index: 2;
    background-color: rgba(255, 255, 255, 0.85);
    padding: 8px;
    border-radius: 4px;
    width: 90%;
  }
  .cell-bg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-size: cover;
    background-position: center;
    opacity: 0.85;
    z-index: 1;
  }
  .filled-cell .cell-content {
    background-color: rgba(230, 247, 255, 0.85);
  }
  .correct .cell-content {
    background-color: rgba(183, 235, 143, 0.85);
  }
  .incorrect .cell-content {
    background-color: rgba(255, 204, 199, 0.85);
  }
`;

    // Load coaster data
    async function loadCoasterData() {
      try {
        // Replace with the path to your JSON file
        const response = await fetch('coasterData.json');
        if (!response.ok) {
          throw new Error('Failed to load coaster data');
        }

        const data = await response.json();

        // Process and filter the data
        if (data && data.coasters && data.coasters.length > 0) {
          // Filter out coasters with missing essential data
          allCoasters = data.coasters.filter(coaster => {
            return coaster.name &&
              coaster.park &&
              coaster.details &&
              coaster.details.manufacturer;
          }).map(coaster => {
            // Normalize and clean the data structure
            const height = coaster.stats?.height ? parseFloat(coaster.stats.height) : 0;
            const length = coaster.stats?.length ? parseFloat(coaster.stats.length) : 0;
            const speed = coaster.stats?.speed ? parseFloat(coaster.stats.speed) : 0;
            const angle = coaster.stats?.angle ? parseFloat(coaster.stats.angle) : 0;
            const inversions = coaster.stats?.inversions ? parseInt(coaster.stats.inversions) : 0;

            // Parse year carefully
            let year = 0;
            if (coaster.status?.opened) {
              const openedParts = coaster.status.opened.split('-');
              if (openedParts.length > 0) {
                year = parseInt(openedParts[0]) || 0;
              }
            }

            return {
              id: coaster.id,
              name: coaster.name,
              park: coaster.park,
              manufacturer: coaster.details.manufacturer,
              height: height,
              inversions: inversions,
              year: year,
              location: coaster.location || {},
              type: coaster.details?.type || '',
              design: coaster.details?.design || '',
              length: length,
              speed: speed,
              angle: angle,
              country: coaster.location?.country || '',
              category: coaster.details?.category || '',
              mainPicture: coaster.mainPicture || '' // Preserve the image URL
            };
          });

          // Add additional filtering for coasters with valid data
          allCoasters = allCoasters.filter(coaster => {
            // Basic validation to ensure we have valid numerical data where needed
            return coaster.name && coaster.park && coaster.manufacturer;
          });

          console.log(`Loaded ${allCoasters.length} coasters`);

          // Hide loading indicator and show grid
          loadingContainer.style.display = 'none';
          coasterGrid.style.display = 'grid';

          // Initialize game
          initGame();
        } else {
          throw new Error('No coaster data found');
        }
      } catch (error) {
        console.error('Error loading coaster data:', error);
        loadingContainer.innerHTML = `
      <div>Error loading coaster data: ${error.message}</div>
      <button class="game-button" onclick="location.reload()">Retry</button>
    `;
      }
    }

    function debugCellCriteria(row, col) {
      // This function helps debug issues with criteria matching
      console.log(`Debugging criteria for cell (${row}, ${col})`);

      const rowCriterion = rowCriteria[row];
      const colCriterion = colCriteria[col];

      console.log(`Row criterion: ${rowCriterion.type} - ${rowCriterion.value}`);
      console.log(`Column criterion: ${colCriterion.type} - ${colCriterion.value}`);

      const cellSolution = solution.find(s => s.row === row && s.col === col);
      if (cellSolution && cellSolution.selectedCoaster) {
        const coaster = cellSolution.selectedCoaster;
        console.log(`Selected coaster: ${coaster.name} (ID: ${coaster.id})`);
        console.log(`Park: ${coaster.park}`);
        console.log(`Height: ${coaster.height}`);
        console.log(`Speed: ${coaster.speed}`);
        console.log(`Year: ${coaster.year}`);
        console.log(`Length: ${coaster.length}`);
        console.log(`Inversions: ${coaster.inversions}`);

        // Check if the coaster matches row criteria
        const rowMatch = rowCriterion.matcher(coaster, rowCriterion.value);
        console.log(`Matches row criterion? ${rowMatch}`);

        // Check if the coaster matches column criteria
        const colMatch = colCriterion.matcher(coaster, colCriterion.value);
        console.log(`Matches column criterion? ${colMatch}`);
      } else {
        console.log("No solution found for this cell");
      }
    }

    function updateUnitDisplay() {
      // Update column headers with appropriate unit display
      document.querySelectorAll('.cell.header').forEach((cell, index) => {
        // Skip the first cell (corner cell) and row headers (every 4th cell starting from 5th)
        if (index === 0 || (index - 4) % 4 === 0) {
          return;
        }

        // Calculate column index (for column headers at positions 1, 2, 3)
        const col = (index - 1) % 4;
        if (col >= 0 && col < colCriteria.length) {
          const criterion = colCriteria[col];

          // Only update if this criterion has different metric/imperial displays
          if (criterion.type === "height" || criterion.type === "length" || criterion.type === "speed") {
            // Get the equivalent value in the current unit system
            const valueIndex = criterion.values.indexOf(criterion.value);
            const displayValue = useMetricUnits && criterion.metricValues ?
              criterion.metricValues[valueIndex] : criterion.values[valueIndex];

            cell.innerHTML = `
          <div>${displayValue}</div>
          <div class="criteria-info">${criterion.type}${useMetricUnits ? ' (metric)' : ' (imperial)'}</div>
        `;
          }
        }
      });
    }

    function validateAllSolutions() {
      console.log("Validating all solutions...");
      let allValid = true;

      for (const cellSolution of solution) {
        const { row, col, selectedCoaster } = cellSolution;
        const rowCriterion = rowCriteria[row];
        const colCriterion = colCriteria[col];

        console.log(`\nValidating cell (${row}, ${col}) - Coaster: ${selectedCoaster.name}`);
        console.log(`Row criterion: ${rowCriterion.type} = ${rowCriterion.value}`);
        console.log(`Column criterion: ${colCriterion.type} = ${colCriterion.value}`);
        console.log(`Coaster details: height=${selectedCoaster.height}, length=${selectedCoaster.length}, speed=${selectedCoaster.speed}`);

        const rowMatch = rowCriterion.matcher(selectedCoaster, rowCriterion.value);
        const colMatch = colCriterion.matcher(selectedCoaster, colCriterion.value);

        console.log(`Row match result: ${rowMatch}, Column match result: ${colMatch}`);

        if (!rowMatch || !colMatch) {
          console.error(`Invalid solution at (${row}, ${col}): ${selectedCoaster.name}`);
          allValid = false;
        }
      }

      if (allValid) {
        console.log("All solutions are valid!");
      } else {
        console.error("Found invalid solutions!");
      }

      return allValid;
    }

    // Initialize game
    async function initGame() {
      // Remove unit toggle related code
      fixMatcherFunctions();

      //newGameBtn.addEventListener('click', createNewGame);
      newGameBtn.style.display = 'none';
      endGameBtn.addEventListener('click', endGame);

      const rng = await getSeededRandom();
      setupDailyGame(rng);
      //createNewGame();
    }

    function fixMatcherFunctions() {
      // Update height matcher
      colCriteriaOptions.find(c => c.type === "height").matcher = function (coaster, value) {
        // Convert meters to feet for comparison
        const heightMeters = typeof coaster.height === 'number' ? coaster.height :
          parseFloat(coaster.height) || 0;
        const heightFeet = heightMeters * 3.28084;

        // Compare against imperial thresholds
        if (value === "< 100ft") return heightFeet > 0 && heightFeet < 100;
        if (value === "100 - 149.9ft") return heightFeet >= 100 && heightFeet < 150;
        if (value === "150 - 199.9ft") return heightFeet >= 150 && heightFeet < 200;
        if (value === "> 200ft") return heightFeet >= 200;

        return false;
      };

      // Update length matcher
      colCriteriaOptions.find(c => c.type === "length").matcher = function (coaster, value) {
        // Convert meters to feet for comparison
        const lengthMeters = typeof coaster.length === 'number' ? coaster.length :
          parseFloat(coaster.length) || 0;
        const lengthFeet = lengthMeters * 3.28084;

        // Compare against imperial thresholds
        if (value === "< 2000ft") return lengthFeet > 0 && lengthFeet < 2000;
        if (value === "2000 - 3000ft") return lengthFeet >= 2000 && lengthFeet <= 3000;
        if (value === "3000 - 4000ft") return lengthFeet > 3000 && lengthFeet <= 4000;
        if (value === "> 4000ft") return lengthFeet > 4000;

        return false;
      };

      // Update speed matcher
      colCriteriaOptions.find(c => c.type === "speed").matcher = function (coaster, value) {
        // Convert km/h to mph for comparison
        const speedKmh = typeof coaster.speed === 'number' ? coaster.speed :
          parseFloat(coaster.speed) || 0;
        const speedMph = speedKmh * 0.621371;

        // Compare against imperial thresholds
        if (value === "< 45mph") return speedMph > 0 && speedMph < 45;
        if (value === "45 - 59.9mph") return speedMph >= 45 && speedMph < 60;
        if (value === "60 - 74.9mph") return speedMph >= 60 && speedMph < 75;
        if (value === "> 75mph") return speedMph >= 75;

        return false;
      };
    }

    function setupUnitValues() {
      // Store the imperial values (original)
      imperialCriteriaValues.height = ["< 100ft", "100 - 149.9ft", "150 - 199.9ft", "> 200ft"];
      imperialCriteriaValues.length = ["< 2000ft", "2000 - 3000ft", "3000 - 4000ft", "> 4000ft"];
      imperialCriteriaValues.speed = ["< 45mph", "45 - 59.9mph", "60 - 74.9mph", "> 75mph"];

      // Store the metric values
      metricCriteriaValues.height = ["< 30m", "30 - 45.9m", "46 - 60.9m", "> 61m"];
      metricCriteriaValues.length = ["< 610m", "610 - 915m", "915 - 1220m", "> 1220m"];
      metricCriteriaValues.speed = ["< 72km/h", "72 - 96km/h", "97 - 120km/h", "> 120km/h"];

      // Ensure the column criteria options use these values
      colCriteriaOptions.forEach(option => {
        if (option.type === "height") {
          option.values = [...imperialCriteriaValues.height];
          option.metricValues = [...metricCriteriaValues.height];
        }
        else if (option.type === "length") {
          option.values = [...imperialCriteriaValues.length];
          option.metricValues = [...metricCriteriaValues.length];
        }
        else if (option.type === "speed") {
          option.values = [...imperialCriteriaValues.speed];
          option.metricValues = [...metricCriteriaValues.speed];
        }
      });
    }

    function createNewGame() {
      // Clear any existing game state
      solution = [];
      gameGrid = Array(3).fill().map(() => Array(3).fill(null));
      usedCoasterIds = new Set();
      resultsMessage.style.display = 'none';

      // Reset cell classes
      document.querySelectorAll('.cell.input-cell').forEach(cell => {
        cell.innerHTML = '';
        cell.className = 'cell input-cell';
        delete cell.dataset.coasterId;
      });

      // Try to generate a valid puzzle
      let puzzleGenerated = false;
      let maxTries = 10; // Increased from 5 to 10
      let tries = 0;

      while (!puzzleGenerated && tries < maxTries) {
        puzzleGenerated = generatePuzzle();
        tries++;
      }

      if (!puzzleGenerated) {
        alert("Could not generate a valid puzzle. Please try again.");
        return;
      }

      // Generate grid UI
      renderGrid();

      // Validate all solutions after grid creation
      validateAllSolutions();
    }

    // Row criteria options
    const rowCriteriaOptions = [
      {
        type: "manufacturer",
        values: [
          "Arrow Dynamics",
          "Bolliger & Mabillard",
          "Custom Coasters International",
          "Dinn Corporation",
          "Gerstlauer Amusement Rides GmbH",
          "Great Coasters International",
          "Intamin",
          "Morgan Manufacturing",
          "Philadelphia Toboggan Coasters, Inc.",
          "Pinfari",
          "Premier Rides",
          "Rocky Mountain Construction",
          "Schwarzkopf",
          "S&S Worldwide",
          "Togo",
          "Vekoma",
          "Zamperla",
          "Zierer"
        ],
        matcher: function (coaster, value) {
          return coaster.manufacturer && coaster.manufacturer.includes(value);
        }
      },
      {
        type: "coaster type",
        values: ["Steel", "Wood"],
        matcher: function (coaster, value) {
          if (!coaster.type) return false;
          const type = coaster.type.toLowerCase();
          if (value === "Steel") return type.includes("steel");
          if (value === "Wood") return type.includes("wood");
          return false;
        }
      },
      {
        type: "design",
        values: ["Sit Down", "Inverted or Suspended", "Wing or Flying"],
        matcher: function (coaster, value) {
          if (!coaster.design) return false;
          const design = coaster.design.toLowerCase();

          if (value === "Sit Down") {
            return design.includes("sit") ||
              (!design.includes("inverted") &&
                !design.includes("suspended") &&
                !design.includes("wing") &&
                !design.includes("flying"));
          }

          if (value === "Inverted or Suspended") {
            return design.includes("inverted") || design.includes("suspended");
          }

          if (value === "Wing or Flying") {
            return design.includes("wing") || design.includes("flying");
          }

          return false;
        }
      },
      {
        type: "category",
        values: ["Hybrid", "Launch", "Indoor", "Shuttle", "Spinning Cars", "Twin"],
        matcher: function (coaster, value) {
          if (!coaster.category) return false;
          const category = coaster.category.toLowerCase();

          if (value === "Hybrid") {
            return category.includes("hybrid");
          }

          if (value === "Launch") {
            return category.includes("launch");
          }

          if (value === "Indoor") {
            return category.includes("indoor");
          }

          if (value === "Shuttle") {
            return category.includes("shuttle");
          }

          if (value === "Spinning Cars") {
            return category.includes("spinning") || category.includes("spin");
          }

          if (value === "Twin") {
            return category.includes("twin") || category.includes("racing") || category.includes("dueling");
          }

          return false;
        }
      },
      {
        type: "country",
        values: ["China", "United States", "Germany", "France", "Japan", "United Kingdom"],
        matcher: function (coaster, value) {
          if (!coaster.country) return false;
          const country = coaster.country.toLowerCase();

          if (value === "United States") {
            return country.includes("united states") || country === "usa" || country === "us";
          }

          if (value === "United Kingdom") {
            return country.includes("united kingdom") || country === "uk" || country.includes("england");
          }

          return country.toLowerCase().includes(value.toLowerCase());
        }
      },
      {
        type: "name",
        values: ["A - F", "G - R", "S - Z"],
        matcher: function (coaster, value) {
          if (!coaster.name) return false;
          const firstLetter = coaster.name.charAt(0).toUpperCase();

          if (value === "A - F") return firstLetter >= 'A' && firstLetter <= 'F';
          if (value === "G - R") return firstLetter >= 'G' && firstLetter <= 'R';
          if (value === "S - Z") return firstLetter >= 'S' && firstLetter <= 'Z';

          return false;
        }
      }
    ];

    // Column criteria options
    const colCriteriaOptions = [
      {
        type: "height",
        values: ["< 100ft", "100 - 149.9ft", "150 - 199.9ft", "> 200ft"],
        metricValues: ["< 30m", "30 - 45.9m", "46 - 60.9m", "> 61m"],
        matcher: function (coaster, value) {
          // Height data is in meters, convert to feet for comparison
          const heightMeters = typeof coaster.height === 'number' ? coaster.height :
            parseFloat(coaster.height) || 0;
          const heightFeet = heightMeters * 3.28084;

          if (value === "< 100ft" || value === "< 30m") return heightFeet > 0 && heightFeet < 100;
          if (value === "100 - 149.9ft" || value === "30 - 45.9m") return heightFeet >= 100 && heightFeet < 150;
          if (value === "150 - 199.9ft" || value === "46 - 60.9m") return heightFeet >= 150 && heightFeet < 200;
          if (value === "> 200ft" || value === "> 61m") return heightFeet >= 200;

          return false;
        }
      },
      {
        type: "inversions",
        values: ["0", "1 - 3", "4 - 6", "7+"],
        metricValues: ["0", "1 - 3", "4 - 6", "7+"], // Same in both systems
        matcher: function (coaster, value) {
          // Ensure inversions is properly parsed to an integer
          const inversions = typeof coaster.inversions === 'number' ? coaster.inversions :
            parseInt(coaster.inversions) || 0;

          if (value === "0") return inversions === 0;
          if (value === "1 - 3") return inversions >= 1 && inversions <= 3;
          if (value === "4 - 6") return inversions >= 4 && inversions <= 6;
          if (value === "7+") return inversions >= 7;

          return false;
        }
      },
      {
        type: "year",
        values: ["< 1980", "1980 - 1999", "2000 - 2009", "2010 - 2019", "â‰¥ 2020"],
        metricValues: ["< 1980", "1980 - 1999", "2000 - 2009", "2010 - 2019", "â‰¥ 2020"], // Same in both systems
        matcher: function (coaster, value) {
          // Ensure year is properly parsed to an integer
          let year = 0;
          if (typeof coaster.year === 'number') {
            year = coaster.year;
          } else if (typeof coaster.year === 'string') {
            year = parseInt(coaster.year) || 0;
          } else if (coaster.status && coaster.status.opened) {
            const openedDate = coaster.status.opened.split('-');
            if (openedDate.length > 0) {
              year = parseInt(openedDate[0]) || 0;
            }
          }

          if (value === "< 1980") return year > 0 && year < 1980;
          if (value === "1980 - 1999") return year >= 1980 && year <= 1999;
          if (value === "2000 - 2009") return year >= 2000 && year <= 2009;
          if (value === "2010 - 2019") return year >= 2010 && year <= 2019;
          if (value === "â‰¥ 2020") return year >= 2020;

          return false;
        }
      },
      {
        type: "length",
        values: ["< 2000ft", "2000 - 3000ft", "3000 - 4000ft", "> 4000ft"],
        metricValues: ["< 610m", "610 - 915m", "915 - 1220m", "> 1220m"],
        matcher: function (coaster, value) {
          // Length data is in meters, convert to feet for comparison
          const lengthMeters = typeof coaster.length === 'number' ? coaster.length :
            parseFloat(coaster.length) || 0;
          const lengthFeet = lengthMeters * 3.28084;

          if (value === "< 2000ft" || value === "< 610m") return lengthFeet > 0 && lengthFeet < 2000;
          if (value === "2000 - 3000ft" || value === "610 - 915m") return lengthFeet >= 2000 && lengthFeet <= 3000;
          if (value === "3000 - 4000ft" || value === "915 - 1220m") return lengthFeet > 3000 && lengthFeet <= 4000;
          if (value === "> 4000ft" || value === "> 1220m") return lengthFeet > 4000;

          return false;
        }
      },
      {
        type: "speed",
        values: ["< 45mph", "45 - 59.9mph", "60 - 74.9mph", "> 75mph"],
        metricValues: ["< 72km/h", "72 - 96km/h", "97 - 120km/h", "> 120km/h"],
        matcher: function (coaster, value) {
          // Speed data is in km/h, convert to mph for comparison
          const speedKmh = typeof coaster.speed === 'number' ? coaster.speed :
            parseFloat(coaster.speed) || 0;
          const speedMph = speedKmh * 0.621371;

          if (value === "< 45mph" || value === "< 72km/h") return speedMph > 0 && speedMph < 45;
          if (value === "45 - 59.9mph" || value === "72 - 96km/h") return speedMph >= 45 && speedMph < 60;
          if (value === "60 - 74.9mph" || value === "97 - 120km/h") return speedMph >= 60 && speedMph < 75;
          if (value === "> 75mph" || value === "> 120km/h") return speedMph >= 75;

          return false;
        }
      }
    ];

    function simpleEncrypt(id) {
      return btoa((id * 73 + 17).toString()); // multiply by 73, add 17, then base64 encode
    }

    function simpleDecrypt(encoded) {
      return (parseInt(atob(encoded)) - 17) / 73;
    }

    function shuffleArray(array, rng) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function getDailySeed() {
      const now = new Date();

      // Get UTC time in milliseconds
      const utcTimestamp = now.getTime() + (now.getTimezoneOffset() * 60000);

      // Eastern Time is UTC-5 in winter, UTC-4 in summer (Daylight Saving Time)
      // Let's detect whether daylight saving time is in effect
      const estOffset = isDST(new Date(utcTimestamp)) ? -4 : -5;

      // Shift the UTC timestamp by Eastern offset
      const estTimestamp = utcTimestamp + (estOffset * 60 * 60 * 1000);
      const estDate = new Date(estTimestamp);

      const year = estDate.getFullYear();
      const month = (estDate.getMonth() + 1).toString().padStart(2, '0');
      const day = estDate.getDate().toString().padStart(2, '0');

      return `${year}-${month}-${day}`;
    }

    function isDST(date) {
      const jan = new Date(date.getFullYear(), 0, 1).getTimezoneOffset();
      const jul = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      return Math.max(jan, jul) !== date.getTimezoneOffset();
    }

    function mulberry32(seed) {
      let t = seed += 0x6D2B79F5;
      return function () {
        t = Math.imul(t ^ (t >>> 15), 1 | t);
        t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      }
    }

    async function getSeededRandom() {
      const seedString = getDailySeed();
      const buffer = new TextEncoder().encode(seedString);
      const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const seed = hashArray.slice(0, 4).reduce((a, b) => (a << 8) | b, 0); // 4 bytes => 32-bit number
      return mulberry32(seed);
    }

    function generatePuzzle(rng) {
      let maxAttempts = 100;
      let attempts = 0;
      let success = false;

      while (!success && attempts < maxAttempts) {
        attempts++;
        solution = [];

        // Shuffle criteria options for row and column separately
        const shuffledRowOptions = shuffleArray([...rowCriteriaOptions], rng);
        const shuffledColOptions = shuffleArray([...colCriteriaOptions], rng);

        // Select 3 random criteria for rows and columns
        const selectedRowCriteria = shuffledRowOptions.slice(0, 3);
        const selectedColCriteria = shuffledColOptions.slice(0, 3);

        // Initialize row and column criteria arrays
        rowCriteria = [];
        colCriteria = [];

        // Pick random values for row criteria
        for (let i = 0; i < 3; i++) {
          const criteriaType = selectedRowCriteria[i];
          const value = criteriaType.values[Math.floor(rng() * criteriaType.values.length)];
          rowCriteria.push({
            type: criteriaType.type,
            value,
            matcher: criteriaType.matcher
          });
        }

        // Pick random values for column criteria
        for (let i = 0; i < 3; i++) {
          const criteriaType = selectedColCriteria[i];
          const value = criteriaType.values[Math.floor(rng() * criteriaType.values.length)];
          colCriteria.push({
            type: criteriaType.type,
            value,
            matcher: criteriaType.matcher
          });
        }

        // Check if all cells have at least one matching coaster
        let validCellCount = 0;
        let cellSolutions = Array(3).fill().map(() => Array(3).fill(null));
        let usedCoasterIdsTemp = new Set(); // temp, for building the board

        // Find possible coasters for each cell
        for (let row = 0; row < 3; row++) {
          for (let col = 0; col < 3; col++) {
            const matchingCoasters = allCoasters.filter(coaster =>
              rowCriteria[row].matcher(coaster, rowCriteria[row].value) &&
              colCriteria[col].matcher(coaster, colCriteria[col].value)
            );

            if (matchingCoasters.length > 0) {
              validCellCount++;
              cellSolutions[row][col] = {
                row,
                col,
                possibleCoasters: matchingCoasters
              };
            }
          }
        }

        if (validCellCount !== 9) {
          // Not enough coasters to fill grid
          continue;
        }

        // Try to fill the grid with unique coasters
        const cellsToFill = [];
        for (let row = 0; row < 3; row++) {
          for (let col = 0; col < 3; col++) {
            cellsToFill.push({
              row,
              col,
              possibleCoasters: cellSolutions[row][col].possibleCoasters
            });
          }
        }

        // Sort cells by fewest options first
        cellsToFill.sort((a, b) => a.possibleCoasters.length - b.possibleCoasters.length);

        let allCellsFilled = true;

        for (const cell of cellsToFill) {
          const available = cell.possibleCoasters.filter(c => !usedCoasterIdsTemp.has(c.id));

          if (available.length === 0) {
            allCellsFilled = false;
            break;
          }

          const selected = available[Math.floor(rng() * available.length)];
          usedCoasterIdsTemp.add(selected.id);

          solution.push({
            row: cell.row,
            col: cell.col,
            selectedCoaster: selected,
            possibleCoasters: cell.possibleCoasters
          });
        }

        if (allCellsFilled) {
          success = true;
        }
      }

      console.log(`Puzzle generation ${success ? 'succeeded' : 'failed'} after ${attempts} attempt(s).`);

      if (!success) {
        console.warn(`Failed to generate valid puzzle after ${maxAttempts} attempts`);
        return false;
      }

      // Final validation
      const validationResult = validateSolution();
      if (!validationResult.valid) {
        console.warn("Generated puzzle has validation issues:", validationResult.message);
        return false;
      }

      return true;
    }

    async function setupDailyGame(rng) {
      const seed = getDailySeed();
      console.log(`Starting daily game with seed: ${seed}`);

      const savedState = loadGameState();
      if (savedState && savedState.date === seed) {
        console.log('Loading saved game...');

        loadGameFromState(savedState);
        restoreCriteriaMatchers();

        if (savedState.gameEnded) {
          console.log('Game was already ended, showing results...');
          setTimeout(() => {
            endGame(true); // Silent end
          }, 100);
        }
        return;
      }

      console.log('Generating new daily game...');

      solution = [];
      gameGrid = Array(3).fill().map(() => Array(3).fill(null));
      usedCoasterIds = new Set();
      resultsMessage.style.display = 'none';

      let maxTries = 20;
      let tries = 0;
      let puzzleGenerated = false;

      while (!puzzleGenerated && tries < maxTries) {
        puzzleGenerated = generatePuzzle(rng);
        tries++;
      }

      if (!puzzleGenerated) {
        alert('Failed to generate puzzle. Please try again later.');
        return;
      }

      renderGrid();
      saveGameState();
    }

    function validateSolution() {
      // Check that each solution cell has a selected coaster
      for (const cell of solution) {
        if (!cell.selectedCoaster) {
          return { valid: false, message: "Missing selected coaster for a cell" };
        }

        // Verify the coaster matches both row and column criteria
        const { row, col, selectedCoaster } = cell;
        if (!rowCriteria[row].matcher(selectedCoaster, rowCriteria[row].value)) {
          return {
            valid: false,
            message: `Coaster ${selectedCoaster.name} doesn't match row criteria: ${rowCriteria[row].type} - ${rowCriteria[row].value}`
          };
        }

        if (!colCriteria[col].matcher(selectedCoaster, colCriteria[col].value)) {
          return {
            valid: false,
            message: `Coaster ${selectedCoaster.name} doesn't match column criteria: ${colCriteria[col].type} - ${colCriteria[col].value}`
          };
        }
      }

      return { valid: true };
    }

    function isCoasterValidForCell(coaster, row, col) {
      // More robust validation with error handling
      try {
        if (!coaster || row === undefined || col === undefined) {
          console.log("Invalid parameters for validation check");
          return false;
        }

        if (row < 0 || row >= rowCriteria.length || col < 0 || col >= colCriteria.length) {
          console.log(`Invalid row (${row}) or column (${col}) indices`);
          return false;
        }

        const rowCriterion = rowCriteria[row];
        const colCriterion = colCriteria[col];

        if (!rowCriterion || !colCriterion) {
          console.log("Missing criteria for row or column");
          return false;
        }

        console.log(`\nChecking if coaster "${coaster.name}" is valid for cell (${row}, ${col})`);
        console.log(`Row criterion: ${rowCriterion.type} = ${rowCriterion.value}`);
        console.log(`Column criterion: ${colCriterion.type} = ${colCriterion.value}`);
        console.log(`Coaster details: height=${coaster.height}, length=${coaster.length}, speed=${coaster.speed}`);

        const rowCheck = rowCriterion.matcher(coaster, rowCriterion.value);
        const colCheck = colCriterion.matcher(coaster, colCriterion.value);

        console.log(`Row match result: ${rowCheck}, Column match result: ${colCheck}`);

        return rowCheck && colCheck;
      } catch (error) {
        console.error("Error validating coaster:", error);
        return false;
      }
    }

    function renderGrid() {
      // Clear existing grid
      coasterGrid.innerHTML = '';

      // Add blank corner cell
      const cornerCell = document.createElement('div');
      cornerCell.className = 'cell header';
      cornerCell.innerHTML = '<small>ðŸŽ¢</small>';
      coasterGrid.appendChild(cornerCell);

      // Add column headers
      for (let col = 0; col < 3; col++) {
        const colHeader = document.createElement('div');
        colHeader.className = 'cell header';
        colHeader.innerHTML = `
      <div>${colCriteria[col].value}</div>
      <div class="criteria-info">${colCriteria[col].type}</div>
    `;
        coasterGrid.appendChild(colHeader);
      }

      // Add rows (headers + cells)
      for (let row = 0; row < 3; row++) {
        // Add row header
        const rowHeader = document.createElement('div');
        rowHeader.className = 'cell header';
        rowHeader.innerHTML = `
      <div>${rowCriteria[row].value}</div>
      <div class="criteria-info">${rowCriteria[row].type}</div>
    `;
        coasterGrid.appendChild(rowHeader);

        // Add cells
        for (let col = 0; col < 3; col++) {
          const cell = document.createElement('div');
          cell.className = 'cell input-cell';
          cell.onclick = function () { handleCellClick(this, row, col); };
          cell.dataset.row = row;
          cell.dataset.col = col;
          coasterGrid.appendChild(cell);
        }
      }
    }

    function handleCellClick(cell, row, col) {
      currentCell = cell;

      // Clear previous search inputs and results
      coasterSearchBox.value = '';
      searchList.innerHTML = '';
      searchList.classList.add('hide-search-list');
      selectedCoaster = null;
      selectButton.disabled = true;

      // Show the search modal
      searchModal.style.display = 'block';

      // Focus on the search box
      setTimeout(() => coasterSearchBox.focus(), 100);
    }

    function closeSearchModal() {
      searchModal.style.display = 'none';
      currentCell = null;
    }

    function restoreCriteriaMatchers() {
      rowCriteria.forEach(criterion => {
        const match = rowCriteriaOptions.find(opt => opt.type === criterion.type);
        if (match) {
          criterion.matcher = match.matcher;
        }
      });

      colCriteria.forEach(criterion => {
        const match = colCriteriaOptions.find(opt => opt.type === criterion.type);
        if (match) {
          criterion.matcher = match.matcher;
        }
      });
    }

    async function findCoasters() {
      const query = coasterSearchBox.value.trim();
      if (query.length > 0) {
        searchList.classList.remove('hide-search-list');
        clearTimeout(debounce);
        debounce = setTimeout(async function () {
          try {
            document.getElementById('searchLoading').style.display = 'block'; // show spinner

            const response = await fetch(`https://rcdb-api.vercel.app/api/coasters/search?q=${encodeURIComponent(query)}`);
            const data = await response.json();

            document.getElementById('searchLoading').style.display = 'none'; // hide spinner

            if (data.coasters && data.coasters.length > 0) {
              const results = data.coasters;
              displaySearchResults(results, true); // "true" means live API data
            } else {
              searchList.innerHTML = '<div class="search-item">No coasters found</div>';
            }
          } catch (error) {
            document.getElementById('searchLoading').style.display = 'none'; // hide spinner
            console.error('Error fetching search results:', error);
            searchList.innerHTML = '<div class="search-item">Error searching coasters</div>';
          }
        }, 300);
      } else {
        searchList.classList.add('hide-search-list');
        selectedCoaster = null;
        selectButton.disabled = true;
      }
    }


    function displaySearchResults(results, isApiData = false) {
      searchList.innerHTML = '';

      if (results.length > 0) {
        results.forEach(coaster => {
          const searchItem = document.createElement('div');
          searchItem.classList.add('search-item');

          const parkName = isApiData ? (coaster.park?.name || '') : (coaster.park || '');
          const city = isApiData ? (coaster.city || '') : '';
          const state = isApiData ? (coaster.state || '') : '';
          const country = isApiData ? (coaster.country || '') : '';

          let locationText = '';
          if (city) locationText += city;
          if (state) locationText += (locationText ? ', ' : '') + state;
          if (country) locationText += (locationText ? ', ' : '') + country;

          searchItem.innerHTML = `
            <div><strong>${coaster.name}</strong></div>
            <div class="search-item-details">${parkName}${locationText ? ` - ${locationText}` : ''}</div>
          `;

          searchItem.addEventListener('click', () => {
            document.querySelectorAll('.search-item').forEach(item => {
              item.classList.remove('selected-coaster');
            });
            searchItem.classList.add('selected-coaster');

            selectedCoaster = isApiData ? {
              id: coaster.id,
              name: coaster.name,
              park: coaster.park?.name || '',
              manufacturer: coaster.make || '',
              height: coaster.stats?.height ? parseFloat(coaster.stats.height) : 0,
              length: coaster.stats?.length ? parseFloat(coaster.stats.length) : 0,
              speed: coaster.stats?.speed ? parseFloat(coaster.stats.speed) : 0,
              inversions: coaster.stats?.inversions ? parseInt(coaster.stats.inversions) : 0,
              year: coaster.status?.date?.opened ? parseInt(coaster.status.date.opened.substring(0, 4)) : 0,
              type: coaster.type || '',
              design: coaster.design || '',
              category: '', // not available from the API easily
              country: coaster.country || '',
              mainPicture: coaster.mainPicture?.url || ''
            } : coaster;

            selectButton.disabled = false;
          });

          searchList.appendChild(searchItem);
        });
      } else {
        searchList.innerHTML = '<div class="search-item">No coasters found</div>';
      }
    }

    function formatMeasurement(value, type) {
      if (!value) return "N/A";

      switch (type) {
        case "height":
          return `${(parseFloat(value) * 3.28084).toFixed(1)}ft`;
        case "length":
          return `${(parseFloat(value) * 3.28084).toFixed(1)}ft`;
        case "speed":
          return `${(parseFloat(value) * 0.621371).toFixed(1)}mph`;
        default:
          return value;
      }
    }

    function getStatValue(coaster, type) {
      switch (type.toLowerCase()) {
        case 'height':
          return formatMeasurement(coaster.height, 'height');
        case 'length':
          return formatMeasurement(coaster.length, 'length');
        case 'speed':
          return formatMeasurement(coaster.speed, 'speed');
        case 'year':
          return coaster.year || 'Unknown';
        case 'inversions':
          return coaster.inversions;
        case 'manufacturer':
          return coaster.manufacturer || 'Unknown';
        case 'coaster type':
          return coaster.type || 'Unknown';
        case 'design':
          return coaster.design || 'Unknown';
        case 'category':
          return coaster.category || 'Unknown';
        case 'country':
          return coaster.country || 'Unknown';
        case 'name':
          return coaster.name || 'Unknown';
        default:
          return 'Unknown';
      }
    }

    function handleUnitToggle() {
      useMetricUnits = this.checked;
      document.getElementById('unitLabel').textContent = useMetricUnits ? 'Metric Units' : 'Imperial Units';

      // Update column headers to show the appropriate unit values
      document.querySelectorAll('.cell.header').forEach((cell, index) => {
        // Skip the first cell (corner cell) and row headers
        if (index === 0 || (index - 4) % 4 === 0) {
          return;
        }

        // Calculate column index (for column headers at positions 1, 2, 3)
        const col = (index - 1) % 4;
        if (col >= 0 && col < colCriteria.length) {
          const criterion = colCriteria[col];

          // Only update if this criterion has different metric/imperial displays
          if (criterion.type === "height" || criterion.type === "length" || criterion.type === "speed") {
            // Switch between metric and imperial display values
            const displayValue = useMetricUnits ?
              metricCriteriaValues[criterion.type][colCriteria[col].values.indexOf(colCriteria[col].value)] :
              colCriteria[col].value;

            cell.innerHTML = `
          <div>${displayValue}</div>
          <div class="criteria-info">${criterion.type}${useMetricUnits ? ' (metric)' : ' (imperial)'}</div>
        `;
          }
        }
      });

      // Update any filled cells to show stats in the correct units
      document.querySelectorAll('.cell.input-cell.filled-cell').forEach(cell => {
        if (cell.dataset.coasterId) {
          const coasterId = parseInt(cell.dataset.coasterId);
          const coaster = allCoasters.find(c => c.id === coasterId);
          if (coaster) {
            // Keep the same showStats state
            const isShowingStats = cell.querySelector('.stats-info') !== null;
            updateCellDisplay(cell, coaster, isShowingStats);
          }
        }
      });
    }

    function updateCellDisplay(cell, coaster, showStats = false) {
      saveGameState();

      // Clear previous content
      cell.innerHTML = '';

      // Create background div
      const bgDiv = document.createElement('div');
      bgDiv.className = 'cell-bg';
      if (coaster.mainPicture) {
        bgDiv.style.backgroundImage = `url('${coaster.mainPicture}')`;
      }

      // Create content div (wrapper for text content only)
      const contentWrapper = document.createElement('div');
      contentWrapper.className = 'cell-content';

      let statsHTML = '';
      if (showStats) {
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        const rowCriterion = rowCriteria[row];
        const colCriterion = colCriteria[col];

        statsHTML = `
          <div class="stats-info">
            ${rowCriterion.type}: ${getStatValue(coaster, rowCriterion.type)}<br>
            ${colCriterion.type}: ${getStatValue(coaster, colCriterion.type)}
          </div>
        `;
      }

      contentWrapper.innerHTML = `
        <div>${coaster.name}</div>
        <div class="park-name">${coaster.park}</div>
        ${statsHTML}
      `;

      // Add RCDB link
      const rcdbLink = document.createElement('a');
      rcdbLink.href = `https://rcdb.com/${coaster.id}.htm`;
      rcdbLink.target = '_blank';
      rcdbLink.className = 'rcdb-link';
      rcdbLink.textContent = 'View on RCDB';
      contentWrapper.appendChild(rcdbLink);

      // Append elements
      cell.appendChild(bgDiv);
      cell.appendChild(contentWrapper);

      // Mark cell as filled
      cell.classList.add('filled-cell');
      cell.dataset.coasterId = coaster.id;
    }

    function addFlipButton(cell, userCoaster, solutionCoaster) {
      // Always remove any old flip button if it exists
      const existingButton = cell.querySelector('.flip-button');
      if (existingButton) existingButton.remove();

      const flipButton = document.createElement('button');
      flipButton.className = 'flip-button';
      flipButton.innerHTML = 'ðŸ”„';
      flipButton.style.position = 'absolute';
      flipButton.style.bottom = '5px';
      flipButton.style.right = '5px';
      flipButton.style.background = 'rgba(255,255,255,0.7)';
      flipButton.style.border = 'none';
      flipButton.style.borderRadius = '50%';
      flipButton.style.width = '30px';
      flipButton.style.height = '30px';
      flipButton.style.cursor = 'pointer';
      flipButton.style.fontSize = '18px';
      flipButton.title = 'Toggle between your guess and solution';
      flipButton.style.zIndex = '5';

      // Setup data attributes for tracking
      cell.dataset.currentView = cell.dataset.currentView || 'user';
      cell.dataset.userCoasterId = userCoaster.id;
      cell.dataset.solutionCoasterId = solutionCoaster.id;

      flipButton.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent triggering cell click
        const isUserView = cell.dataset.currentView === 'user';
        const nextCoaster = isUserView ? solutionCoaster : userCoaster;

        // Update coaster info
        updateCellDisplay(cell, nextCoaster, true);

        // Re-add the flip button
        addFlipButton(cell, userCoaster, solutionCoaster);

        // Remove previous color classes
        cell.classList.remove('correct', 'incorrect', 'unguessed', 'solution-view');

        if (isUserView) {
        // Flipping to solution view
        cell.classList.add('solution-view');
      
        // FORCE background manually gray (because updateCellDisplay resets it)
        const content = cell.querySelector('.cell-content');
        if (content) {
          content.style.backgroundColor = '#cccccc';
        }
      } else {
        // Flipping back to user guess
        if (userCoaster.id === solutionCoaster.id) {
          cell.classList.add('correct');
        } else {
          cell.classList.add('incorrect');
        }
      }

        // Toggle view state
        cell.dataset.currentView = isUserView ? 'solution' : 'user';
      });

      // Finally, add the button to the cell
      cell.appendChild(flipButton);
    }

    function endGame(silent = false) {
      gameEnded = true;

      let correctCells = [];

      document.querySelectorAll('.cell.input-cell').forEach(cell => {
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);

        const coasterId = cell.dataset.coasterId ? parseInt(cell.dataset.coasterId) : null;
        const selectedCoaster = coasterId ? allCoasters.find(c => c.id === coasterId) : null;

        const solutionCoaster = solution.find(s => s.row === row && s.col === col)?.selectedCoaster;

        if (selectedCoaster) {
          if (isCoasterValidForCell(selectedCoaster, row, col)) {
            // Exact match with the correct solution
            cell.classList.add('correct');
            correctCells.push({ row, col });
          } else {
            // Wrong guess
            cell.classList.add('incorrect');
          }

          // Always show the guessed coaster
          updateCellDisplay(cell, selectedCoaster, true);

          // Only add flip button if solution exists and guess was different
          if (solutionCoaster) {
            addFlipButton(cell, selectedCoaster, solutionCoaster);
          }

        } else {
          // No guess â€” fill with correct solution
          updateCellDisplay(cell, solutionCoaster, true);
          cell.classList.add('unguessed');
        }
      });

      // Correct count out of 9
      resultsMessage.style.display = 'block';
      const correctCount = document.querySelectorAll('.cell.correct').length;
      resultsMessage.textContent = `Game over! You had ${correctCount} correct answers out of 9 cells.`;
      resultsMessage.className = 'check-results success';

      createEmojiResults();

      document.querySelectorAll('.cell.input-cell').forEach(cell => {
        cell.onclick = null;
        cell.classList.remove('input-cell');
      });

      const endButton = document.getElementById('endGameBtn');
      if (endButton) {
        endButton.style.display = 'none';
      }

      saveGameState();
    }

    // Event listeners
    coasterSearchBox.addEventListener('input', findCoasters);

    selectButton.addEventListener('click', () => {
      if (currentCell && selectedCoaster) {
        // Add coaster to used set
        usedCoasterIds.add(selectedCoaster.id);

        // Update cell with coaster info and background image, but don't show stats yet
        updateCellDisplay(currentCell, selectedCoaster, false);

        // Update game grid
        const row = parseInt(currentCell.dataset.row);
        const col = parseInt(currentCell.dataset.col);
        gameGrid[row][col] = selectedCoaster;

        saveGameState();
        closeSearchModal();
      }
    });

    // Close modal if clicking outside of it
    window.addEventListener('click', (event) => {
      if (event.target === searchModal) {
        closeSearchModal();
      }
    });

    // Close search results if clicking outside
    document.addEventListener('click', (event) => {
      if (!event.target.closest('.search-container')) {
        searchList.classList.add('hide-search-list');
      }
    });

    // Allow pressing Enter to search
    coasterSearchBox.addEventListener('keypress', (event) => {
      if (event.key === 'Enter' && selectedCoaster) {
        selectButton.click();
      }
    });

    function applyUpdatedStyles() {
      // Add the updated styles to the document
      const styleElement = document.createElement('style');
      styleElement.textContent = updatedCellStyles;
      document.head.appendChild(styleElement);
    }

    function createEmojiResults() {
      // Remove existing container if it exists
      const existingContainer = document.querySelector('.emoji-result-container');
      if (existingContainer) {
        existingContainer.remove();
      }

      let emojiGrid = '';

      for (let row = 0; row < 3; row++) {
        let rowEmojis = '';
        for (let col = 0; col < 3; col++) {
          const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
          if (!cell) {
            rowEmojis += 'â¬›'; // If cell somehow missing, treat it as empty
            continue;
          }

          if (cell.classList.contains('correct')) {
            rowEmojis += 'ðŸŸ©';
          } else if (cell.classList.contains('incorrect')) {
            rowEmojis += 'ðŸŸ¥';
          } else if (cell.classList.contains('unguessed')) {
            rowEmojis += 'â¬œ';
          } else {
            rowEmojis += 'â¬›';
          }
        }

        emojiGrid += rowEmojis;
        if (row !== 2) { // Only add newline if it's not the last row
          emojiGrid += '\n';
        }
      }

      const puzzleNumber = getPuzzleNumber();
      const resultText = `Coaster Grid #${puzzleNumber}\n${emojiGrid}`;

      const resultContainer = document.createElement('div');
      resultContainer.className = 'emoji-result-container';
      resultContainer.style.margin = '20px auto';
      resultContainer.style.padding = '15px';
      resultContainer.style.backgroundColor = '#f5f5f5';
      resultContainer.style.borderRadius = '8px';
      resultContainer.style.maxWidth = '300px';
      resultContainer.style.textAlign = 'center';

      const resultTextArea = document.createElement('textarea');
      resultTextArea.value = resultText;
      resultTextArea.readOnly = true;
      resultTextArea.rows = 5;
      resultTextArea.style.width = '100%';
      resultTextArea.style.marginBottom = '10px';
      resultTextArea.style.resize = 'none';
      resultTextArea.style.fontFamily = 'monospace';

      const copyButton = document.createElement('button');
      copyButton.textContent = 'Copy Results';
      copyButton.className = 'game-button';
      copyButton.onclick = function () {
        resultTextArea.select();
        document.execCommand('copy');
        copyButton.textContent = 'Copied!';
        setTimeout(() => {
          copyButton.textContent = 'Copy Results';
        }, 2000);
      };

      resultContainer.appendChild(resultTextArea);
      resultContainer.appendChild(copyButton);

      resultsMessage.after(resultContainer);

      return resultText;
    }

    function saveGameState() {
      const state = {
        date: getDailySeed(),
        grid: gameGrid.map(row => row.map(coaster => coaster ? simpleEncrypt(coaster.id) : null)), // encrypt IDs
        used: Array.from(usedCoasterIds).map(id => simpleEncrypt(id)), // encrypt used coaster IDs
        rowCriteria: rowCriteria,
        colCriteria: colCriteria,
        solution: solution.map(cell => ({
          row: cell.row,
          col: cell.col,
          selectedCoasterId: simpleEncrypt(cell.selectedCoaster.id) // encrypt solution coaster IDs
        })),
        gameEnded: gameEnded
      };
      localStorage.setItem('coasterGridDaily', JSON.stringify(state));
    }

    function loadGameState() {
      const saved = localStorage.getItem('coasterGridDaily');
      if (saved) {
        try {
          return JSON.parse(saved);
        } catch (e) {
          console.error('Failed to parse saved game state', e);
        }
      }
      return null;
    }

    function forceShowEndState() {
      gameEnded = true;

      let correctCells = [];
      let emptyCells = [];

      document.querySelectorAll('.cell[data-row][data-col]').forEach(cell => {
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        const cellSolution = solution.find(s => s.row === row && s.col === col);

        if (cell.dataset.coasterId) {
          const coasterId = parseInt(cell.dataset.coasterId);
          const selectedCoaster = allCoasters.find(c => c.id === coasterId);

          if (selectedCoaster && cellSolution && selectedCoaster.id === cellSolution.selectedCoaster.id) {
            cell.classList.add('correct');
            updateCellDisplay(cell, selectedCoaster, true);
            correctCells.push({ row, col });
          } else {
            cell.classList.add('incorrect');
            updateCellDisplay(cell, selectedCoaster, true);
          }
        } else {
          emptyCells.push({ row, col });
        }
      });

      // Fill in the blanks with correct solutions
      emptyCells.forEach(({ row, col }) => {
        const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
        const cellSolution = solution.find(s => s.row === row && s.col === col);

        if (cell && cellSolution && cellSolution.selectedCoaster) {
          updateCellDisplay(cell, cellSolution.selectedCoaster, true);
          cell.classList.add('unguessed');
        }
      });

      resultsMessage.style.display = 'block';
      resultsMessage.textContent = `Game over! You had ${correctCells.length} correct answers out of 9 cells.`;
      resultsMessage.className = 'check-results success';

      createEmojiResults();
    }

    function loadGameFromState(state) {
      gameGrid = state.grid.map(row => row.map(encId => encId ? allCoasters.find(c => c.id === simpleDecrypt(encId)) : null));
      usedCoasterIds = new Set(state.used.map(encId => simpleDecrypt(encId)));
      rowCriteria = state.rowCriteria;
      colCriteria = state.colCriteria;

      solution = state.solution.map(cell => {
        const coaster = allCoasters.find(c => c.id === simpleDecrypt(cell.selectedCoasterId));
        return {
          row: cell.row,
          col: cell.col,
          selectedCoaster: coaster
        };
      });

      renderGrid();

      // After rendering, restore filled cells
      gameGrid.forEach((row, r) => {
        row.forEach((coaster, c) => {
          if (coaster) {
            const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
            if (cell) {
              updateCellDisplay(cell, coaster, false); // show without stats first
            }
          }
        });
      });

      // THEN if game already ended:
      if (state.gameEnded) {
        setTimeout(() => {
          document.querySelectorAll('.cell.input-cell').forEach(cell => {
            cell.onclick = null;
            cell.classList.remove('input-cell');
          });

          forceShowEndState();
        }, 50); // slight delay to make sure DOM is ready
      }
    }

    function getPuzzleNumber() {
      const estNow = new Date(new Date().toLocaleString("en-US", { timeZone: "America/New_York" }));
      const startDate = new Date('2025-04-28T00:00:00-04:00'); // April 28, 2025, EST midnight

      const msInDay = 1000 * 60 * 60 * 24;
      const diffInMs = estNow - startDate;
      const diffInDays = Math.floor(diffInMs / msInDay);

      return diffInDays + 1;
    }

    function toggleSettingsPanel() {
      const panel = document.getElementById('settingsPanel');
      const overlay = document.getElementById('overlay');
      if (panel.style.display === 'block') {
        panel.style.display = 'none';
        overlay.style.display = 'none';
      } else {
        panel.style.display = 'block';
        overlay.style.display = 'block';
      }
    }

    function toggleInfoPanel() {
      const panel = document.getElementById('infoPanel');
      const overlay = document.getElementById('overlay');
      if (panel.style.display === 'block') {
        panel.style.display = 'none';
        overlay.style.display = 'none';
      } else {
        panel.style.display = 'block';
        overlay.style.display = 'block';
      }
    }

    // Call this function when the page loads
    window.addEventListener('DOMContentLoaded', applyUpdatedStyles);

    // Start the game by loading coaster data
    window.onload = loadCoasterData;

    window.addEventListener('DOMContentLoaded', () => {
      const puzzleNumber = getPuzzleNumber();
      const titleElement = document.querySelector('h1');
      if (titleElement) {
        titleElement.textContent = `Coaster Grid #${puzzleNumber}`;
      }
    });
  </script>
</body>

</html>
