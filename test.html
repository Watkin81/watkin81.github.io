<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Coaster Grid</title>
  <style>
    body { 
      font-family: sans-serif; 
      text-align: center; 
      background: #f5f5f5; 
      margin: 0;
      padding: 20px;
    }
    .grid-container {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(4, 1fr);
      gap: 5px; 
      margin: 20px auto; 
      width: 80vw; 
      max-width: 600px;
    }
    .cell {
      border: 1px solid #ccc; 
      padding: 10px; 
      min-height: 60px; 
      background: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 14px;
    }
    .header { 
      font-weight: bold; 
      background-color: #e0e0e0; 
    }
    .input-cell { 
      cursor: pointer; 
    }
    .input-cell:hover { 
      background: #f0f0f0; 
    }
    .filled-cell {
      background-color: #e6f7ff;
    }
    .park-name {
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }
    .correct {
      background-color: #b7eb8f;
    }
    .incorrect {
      background-color: #ffccc7;
    }
    
    /* Search Modal Styles */
    .search-modal {
      display: none;
      position: fixed;
      z-index: 100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }
    
    .search-content {
      background-color: white;
      margin: 10% auto;
      padding: 20px;
      border-radius: 8px;
      width: 80%;
      max-width: 500px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    .search-container {
      position: relative;
      width: 100%;
    }
    
    #coasterSearchBox {
      width: 100%;
      padding: 12px;
      font-size: 16px;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
      margin-bottom: 10px;
    }
    
    .search-list {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
    }
    
    .search-list .search-item {
      padding: 10px;
      cursor: pointer;
      text-align: left;
      border-bottom: 1px solid #eee;
    }
    
    .search-list .search-item:hover {
      background-color: #f0f0f0;
    }
    
    .hide-search-list {
      display: none;
    }
    
    .search-item-details {
      font-size: 0.8em;
      color: #666;
    }
    
    .selected-coaster {
      background-color: #e6f7ff;
      border-left: 3px solid #1890ff;
    }
    
    .modal-buttons {
      margin-top: 15px;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    
    .modal-button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .cancel-button {
      background-color: #f5f5f5;
      color: #333;
    }
    
    .select-button {
      background-color: #1890ff;
      color: white;
    }
    
    .select-button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    
    .game-controls {
      margin: 20px auto;
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    
    .game-button {
      padding: 10px 20px;
      background-color: #1890ff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .game-button:hover {
      background-color: #40a9ff;
    }
    
    .game-button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    
    .check-results {
      margin-top: 20px;
      padding: 10px;
      border-radius: 4px;
      display: none;
    }
    
    .success {
      background-color: #f6ffed;
      border: 1px solid #b7eb8f;
      color: #52c41a;
    }
    
    .failure {
      background-color: #fff2f0;
      border: 1px solid #ffccc7;
      color: #ff4d4f;
    }
    
    .loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 200px;
    }
    
    .loading-spinner {
      border: 6px solid #f3f3f3;
      border-top: 6px solid #3498db;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    
    .criteria-info {
      font-size: 12px;
      margin-top: 5px;
      color: #666;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <h1>Coaster Grid</h1>
  <p>Fill the grid with roller coasters that match the criteria for both the row and column.</p>

  <div class="game-controls">
    <button class="game-button" id="newGameBtn">New Game</button>
    <button class="game-button" id="endGameBtn">End Game</button>
  </div>

  <div id="loadingContainer" class="loading">
    <div class="loading-spinner"></div>
    <div>Loading coaster data...</div>
  </div>

  <div class="grid-container" id="coasterGrid" style="display: none;">
    <!-- Grid will be generated dynamically -->
  </div>

  <div id="resultsMessage" class="check-results"></div>

  <!-- Search Modal -->
  <div id="searchModal" class="search-modal">
    <div class="search-content">
      <h2>Select a Coaster...</h2>
      <div class="search-container">
        <input type="text" id="coasterSearchBox" placeholder="Type coaster name...">
        <div class="search-list hide-search-list" id="searchList">
          <!-- Search results will be added here -->
        </div>
      </div>
      <div class="modal-buttons">
        <button class="modal-button cancel-button" onclick="closeSearchModal()">Cancel</button>
        <button class="modal-button select-button" id="selectButton" disabled>Select</button>
      </div>
    </div>
  </div>

  <script>
    // Game variables
    let currentCell = null;
    let debounce = null;
    let selectedCoaster = null;
    let gameGrid = [];
    let solution = [];
    let rowCriteria = [];
    let colCriteria = [];
    let allCoasters = [];
    
    // DOM elements
    const searchModal = document.getElementById('searchModal');
    const coasterSearchBox = document.getElementById('coasterSearchBox');
    const searchList = document.getElementById('searchList');
    const selectButton = document.getElementById('selectButton');
    const coasterGrid = document.getElementById('coasterGrid');
    const newGameBtn = document.getElementById('newGameBtn');
    const endGameBtn = document.getElementById('endGameBtn');
    const resultsMessage = document.getElementById('resultsMessage');
    const loadingContainer = document.getElementById('loadingContainer');
    
    // Load coaster data
    async function loadCoasterData() {
      try {
        // Replace with the path to your JSON file
        const response = await fetch('coasterData.json');
        if (!response.ok) {
          throw new Error('Failed to load coaster data');
        }
        
        const data = await response.json();
        
        // Process and filter the data
        if (data && data.coasters && data.coasters.length > 0) {
          // Filter out coasters with missing essential data
          allCoasters = data.coasters.filter(coaster => {
            return coaster.name && 
                   coaster.park && 
                   coaster.details && 
                   coaster.details.manufacturer;
          }).map(coaster => {
            // Normalize the data structure
            return {
              id: coaster.id,
              name: coaster.name,
              park: coaster.park,
              manufacturer: coaster.details.manufacturer,
              height: parseFloat(coaster.stats?.height) || 0,
              inversions: parseInt(coaster.stats?.inversions) || 0,
              year: coaster.status?.opened ? parseInt(coaster.status.opened.split('-')[0]) : 0,
              location: coaster.location || {},
              type: coaster.details?.type || '',
              design: coaster.details?.design || '',
              length: parseFloat(coaster.stats?.length) || 0,
              speed: parseFloat(coaster.stats?.speed) || 0,
              angle: parseFloat(coaster.stats?.angle) || 0,
              country: coaster.location?.country || '',
              category: coaster.details?.category || ''
            };
          });
          
          console.log(`Loaded ${allCoasters.length} coasters`);
          
          // Hide loading indicator and show grid
          loadingContainer.style.display = 'none';
          coasterGrid.style.display = 'grid';
          
          // Initialize game
          initGame();
        } else {
          throw new Error('No coaster data found');
        }
      } catch (error) {
        console.error('Error loading coaster data:', error);
        loadingContainer.innerHTML = `
          <div>Error loading coaster data: ${error.message}</div>
          <button class="game-button" onclick="location.reload()">Retry</button>
        `;
      }
    }
    
    // Initialize game
    function initGame() {
      newGameBtn.addEventListener('click', createNewGame);
      endGameBtn.addEventListener('click', endGame);
      
      createNewGame();
    }
    
    function createNewGame() {
  // Clear any existing game state
  solution = [];
  gameGrid = Array(3).fill().map(() => Array(3).fill(null));
  resultsMessage.style.display = 'none';
  
  // Reset cell classes
  document.querySelectorAll('.cell.input-cell').forEach(cell => {
    cell.innerHTML = '';
    cell.className = 'cell input-cell';
    delete cell.dataset.coasterId;
  });
  
  // Try to generate a valid puzzle
  let puzzleGenerated = false;
  let maxTries = 5;
  let tries = 0;
  
  while (!puzzleGenerated && tries < maxTries) {
    puzzleGenerated = generatePuzzle();
    tries++;
  }
  
  if (!puzzleGenerated) {
    alert("Could not generate a valid puzzle. Please try again.");
    return;
  }
  
  // Generate grid UI
  renderGrid();
}
    
    const rowCriteriaOptions = [
  {
    type: "manufacturer",
    values: ["Bolliger & Mabillard", "Intamin", "Rocky Mountain Construction", "Vekoma", "Arrow Dynamics", "Gerstlauer", "Premier Rides"],
    matcher: function(coaster, value) {
      return coaster.manufacturer && coaster.manufacturer.includes(value);
    }
  },
  {
    type: "coaster type",
    values: ["Steel", "Wooden", "Hybrid"],
    matcher: function(coaster, value) {
      if (!coaster.type) return false;
      const type = coaster.type.toLowerCase();
      if (value === "Steel") return type.includes("steel");
      if (value === "Wooden") return type.includes("wood");
      if (value === "Hybrid") return type.includes("hybrid") || (type.includes("wood") && type.includes("steel"));
      return false;
    }
  },
  {
    type: "design",
    values: ["Inverted", "Dive", "Wing", "Flying", "Stand-Up", "Floorless"],
    matcher: function(coaster, value) {
      return coaster.design && coaster.design.toLowerCase().includes(value.toLowerCase());
    }
  },
  {
    type: "country",
    values: ["USA", "Germany", "Japan", "Canada", "UK"],
    matcher: function(coaster, value) {
      if (!coaster.country) return false;
      const country = coaster.country.toLowerCase();
      if (value === "USA") return country.includes("united states") || country === "usa" || country === "us";
      if (value === "UK") return country.includes("united kingdom") || country === "uk" || country.includes("england");
      return country.toLowerCase().includes(value.toLowerCase());
    }
  },
  {
    type: "category",
    values: ["Single Rail", "Racing", "Dueling", "Indoor", "Water"],
    matcher: function(coaster, value) {
      return coaster.category && coaster.category.toLowerCase().includes(value.toLowerCase());
    }
  },
  {
    type: "name",
    values: ["Starts with A-J", "Starts with K-R", "Starts with S-Z"],
    matcher: function(coaster, value) {
      if (!coaster.name) return false;
      const firstLetter = coaster.name.charAt(0).toUpperCase();
      if (value === "Starts with A-J") return firstLetter >= 'A' && firstLetter <= 'J';
      if (value === "Starts with K-R") return firstLetter >= 'K' && firstLetter <= 'R';
      if (value === "Starts with S-Z") return firstLetter >= 'S' && firstLetter <= 'Z';
      return false;
    }
  }
];

const colCriteriaOptions = [
  {
    type: "height",
    values: ["< 100ft", "100-150ft", "150-200ft", "> 200ft"],
    matcher: function(coaster, value) {
      const height = parseFloat(coaster.height) || 0;
      if (value === "< 100ft") return height > 0 && height < 100;
      if (value === "100-150ft") return height >= 100 && height <= 150;
      if (value === "150-200ft") return height > 150 && height <= 200;
      if (value === "> 200ft") return height > 200;
      return false;
    }
  },
  {
    type: "inversions",
    values: ["0", "1-3", "4-6", "7+"],
    matcher: function(coaster, value) {
      const inversions = parseInt(coaster.inversions) || 0;
      if (value === "0") return inversions === 0;
      if (value === "1-3") return inversions >= 1 && inversions <= 3;
      if (value === "4-6") return inversions >= 4 && inversions <= 6;
      if (value === "7+") return inversions >= 7;
      return false;
    }
  },
  {
    type: "year",
    values: ["Pre-2000", "2000-2010", "2010-2015", "2016+"],
    matcher: function(coaster, value) {
      const year = parseInt(coaster.year) || 0;
      if (value === "Pre-2000") return year > 0 && year < 2000;
      if (value === "2000-2010") return year >= 2000 && year <= 2010;
      if (value === "2010-2015") return year >= 2010 && year <= 2015;
      if (value === "2016+") return year >= 2016;
      return false;
    }
  },
  {
    type: "length",
    values: ["< 2000ft", "2000-2500ft", "2500-3000ft", "> 3000ft"],
    matcher: function(coaster, value) {
      const length = parseFloat(coaster.length) || 0;
      if (value === "< 2000ft") return length > 0 && length < 2000;
      if (value === "2000-2500ft") return length >= 2000 && length <= 2500;
      if (value === "2500-3000ft") return length > 2500 && length <= 3000;
      if (value === "> 3000ft") return length > 3000;
      return false;
    }
  },
  {
    type: "angle",
    values: ["< 60Â°", "60-89Â°", "â‰¥ 90Â°"],
    matcher: function(coaster, value) {
      const angle = parseFloat(coaster.angle) || 0;
      if (value === "< 60Â°") return angle > 0 && angle < 60;
      if (value === "60-89Â°") return angle >= 60 && angle < 90;
      if (value === "â‰¥ 90Â°") return angle >= 90;
      return false;
    }
  },
  {
    type: "speed",
    values: ["< 50mph", "50-60mph", "60-70mph", "> 70mph"],
    matcher: function(coaster, value) {
      const speed = parseFloat(coaster.speed) || 0;
      if (value === "< 50mph") return speed > 0 && speed < 50;
      if (value === "50-60mph") return speed >= 50 && speed <= 60;
      if (value === "60-70mph") return speed > 60 && speed <= 70;
      if (value === "> 70mph") return speed > 70;
      return false;
    }
  }
];
    
    function generatePuzzle() {
  let maxAttempts = 50; // Increased attempts
  let attempts = 0;
  let success = false;
  
  while (!success && attempts < maxAttempts) {
    attempts++;
    solution = [];
    
    // Shuffle criteria options for row and column separately
    const shuffledRowOptions = [...rowCriteriaOptions].sort(() => 0.5 - Math.random());
    const shuffledColOptions = [...colCriteriaOptions].sort(() => 0.5 - Math.random());
    
    // Select 3 random criteria for rows and columns
    const selectedRowCriteria = shuffledRowOptions.slice(0, 3);
    const selectedColCriteria = shuffledColOptions.slice(0, 3);
    
    // Initialize row and column criteria arrays
    rowCriteria = [];
    colCriteria = [];
    
    // For each row, select a value from its criteria type
    for (let i = 0; i < 3; i++) {
      const criteriaType = selectedRowCriteria[i];
      const value = criteriaType.values[Math.floor(Math.random() * criteriaType.values.length)];
      rowCriteria.push({ 
        type: criteriaType.type, 
        value, 
        matcher: criteriaType.matcher 
      });
    }
    
    // For each column, select a value from its criteria type
    for (let i = 0; i < 3; i++) {
      const criteriaType = selectedColCriteria[i];
      const value = criteriaType.values[Math.floor(Math.random() * criteriaType.values.length)];
      colCriteria.push({ 
        type: criteriaType.type, 
        value, 
        matcher: criteriaType.matcher 
      });
    }
    
    // Check if all cells have at least one matching coaster
    let cellValidCount = 0;
    let cellSolutions = Array(3).fill().map(() => Array(3).fill(null));
    
    for (let row = 0; row < 3; row++) {
      for (let col = 0; col < 3; col++) {
        const matchingCoasters = allCoasters.filter(coaster => 
          rowCriteria[row].matcher(coaster, rowCriteria[row].value) && 
          colCriteria[col].matcher(coaster, colCriteria[col].value)
        );
        
        if (matchingCoasters.length > 0) {
          cellValidCount++;
          cellSolutions[row][col] = {
            row,
            col,
            possibleCoasters: matchingCoasters,
            selectedCoaster: matchingCoasters[Math.floor(Math.random() * matchingCoasters.length)]
          };
        }
      }
    }
    
    if (cellValidCount === 9) {
      // All cells have valid options, flatten the solution
      for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 3; col++) {
          solution.push(cellSolutions[row][col]);
        }
      }
      success = true;
    }
  }
  
  if (!success) {
    console.warn(`Could not generate complete puzzle after ${maxAttempts} attempts. Trying with different criteria...`);
    return false; // Signal that we need to try again
  }
  
  return true; // Successfully generated a puzzle
}
    
    function isCoasterValidForCell(coaster, row, col) {
      const rowCheck = rowCriteria[row].matcher(coaster, rowCriteria[row].value);
      const colCheck = colCriteria[col].matcher(coaster, colCriteria[col].value);
      
      return rowCheck && colCheck;
    }
    
    function renderGrid() {
      // Clear existing grid
      coasterGrid.innerHTML = '';
      
      // Add blank corner cell
      const cornerCell = document.createElement('div');
      cornerCell.className = 'cell header';
      cornerCell.innerHTML = '<small>ðŸŽ¢</small>';
      coasterGrid.appendChild(cornerCell);
      
      // Add column headers
      for (let col = 0; col < 3; col++) {
        const colHeader = document.createElement('div');
        colHeader.className = 'cell header';
        colHeader.innerHTML = `
          <div>${colCriteria[col].value}</div>
          <div class="criteria-info">${colCriteria[col].type}</div>
        `;
        coasterGrid.appendChild(colHeader);
      }
      
      // Add rows (headers + cells)
      for (let row = 0; row < 3; row++) {
        // Add row header
        const rowHeader = document.createElement('div');
        rowHeader.className = 'cell header';
        rowHeader.innerHTML = `
          <div>${rowCriteria[row].value}</div>
          <div class="criteria-info">${rowCriteria[row].type}</div>
        `;
        coasterGrid.appendChild(rowHeader);
        
        // Add cells
        for (let col = 0; col < 3; col++) {
          const cell = document.createElement('div');
          cell.className = 'cell input-cell';
          cell.onclick = function() { handleCellClick(this, row, col); };
          cell.dataset.row = row;
          cell.dataset.col = col;
          coasterGrid.appendChild(cell);
        }
      }
    }
    
    function handleCellClick(cell, row, col) {
      currentCell = cell;
      
      // Clear previous search inputs and results
      coasterSearchBox.value = '';
      searchList.innerHTML = '';
      searchList.classList.add('hide-search-list');
      selectedCoaster = null;
      selectButton.disabled = true;
      
      // Show the search modal
      searchModal.style.display = 'block';
      
      // Focus on the search box
      setTimeout(() => coasterSearchBox.focus(), 100);
    }
    
    function closeSearchModal() {
      searchModal.style.display = 'none';
      currentCell = null;
    }
    
    function findCoasters() {
      let query = coasterSearchBox.value.trim().toLowerCase();
      if(query.length > 0) {
        searchList.classList.remove('hide-search-list');
        clearTimeout(debounce);
        debounce = setTimeout(function() {
          // Search locally in our loaded coaster data
          const results = allCoasters.filter(coaster => 
            coaster.name.toLowerCase().includes(query) ||
            coaster.park.toLowerCase().includes(query)
          ).slice(0, 20); // Limit to 20 results to prevent performance issues
          
          displaySearchResults(results);
        }, 300);
      } else {
        searchList.classList.add('hide-search-list');
        selectedCoaster = null;
        selectButton.disabled = true;
      }
    }
    
    function displaySearchResults(results) {
      searchList.innerHTML = '';
      
      if (results.length > 0) {
        results.forEach(coaster => {
          const searchItem = document.createElement('div');
          searchItem.classList.add('search-item');
          
          // Get location information
          let location = '';
          if (coaster.location) {
            if (coaster.location.city) location += coaster.location.city;
            if (coaster.location.state) location += location ? `, ${coaster.location.state}` : coaster.location.state;
            if (coaster.location.country && !location.includes(coaster.location.country)) 
              location += location ? `, ${coaster.location.country}` : coaster.location.country;
          }
          
          // Display search result
          searchItem.innerHTML = `
            <div><strong>${coaster.name}</strong></div>
            <div class="search-item-details">${coaster.park}${location ? ` - ${location}` : ''}</div>
          `;
          
          searchItem.addEventListener('click', () => {
            // Remove selected class from all items
            document.querySelectorAll('.search-item').forEach(item => {
              item.classList.remove('selected-coaster');
            });
            
            // Add selected class to this item
            searchItem.classList.add('selected-coaster');
            
            // Store selected coaster data
            selectedCoaster = coaster;
            
            // Enable select button
            selectButton.disabled = false;
          });
          
          searchList.appendChild(searchItem);
        });
      } else {
        searchList.innerHTML = '<div class="search-item">No coasters found</div>';
      }
    }
    
    function endGame() {
      if (!confirm("Are you ready to end the game and see results?")) {
        return;
      }
      
      // First check which cells are correct
      let correctCells = [];
      let emptyCells = [];
      
      document.querySelectorAll('.cell.input-cell').forEach(cell => {
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        
        if (cell.dataset.coasterId) {
          // Cell is filled, check if it's correct
          const coasterId = parseInt(cell.dataset.coasterId);
          const selectedCoaster = allCoasters.find(c => c.id === coasterId);
          
          if (selectedCoaster && isCoasterValidForCell(selectedCoaster, row, col)) {
            cell.classList.add('correct');
            correctCells.push({row, col});
          } else {
            cell.classList.add('incorrect');
            // Find solution for this cell
            const cellSolution = solution.find(s => s.row === row && s.col === col);
            if (cellSolution) {
              const solutionCoaster = cellSolution.selectedCoaster;
              
              // Display solution
              cell.innerHTML = `
                <div>${solutionCoaster.name}</div>
                <div class="park-name">${solutionCoaster.park}</div>
              `;
              cell.classList.remove('incorrect');
              cell.classList.add('filled-cell', 'correct');
              cell.dataset.coasterId = solutionCoaster.id;
            }
          }
        } else {
          // Cell is empty
          emptyCells.push({row, col});
        }
      });
      
      // Fill empty cells with solutions
      emptyCells.forEach(({row, col}) => {
        const cell = document.querySelector(`.cell.input-cell[data-row="${row}"][data-col="${col}"]`);
        const cellSolution = solution.find(s => s.row === row && s.col === col);
        
        if (cellSolution) {
          const solutionCoaster = cellSolution.selectedCoaster;
          
          // Display solution
          cell.innerHTML = `
            <div>${solutionCoaster.name}</div>
            <div class="park-name"
            <div class="park-name">${solutionCoaster.park}</div>
          `;
          cell.classList.add('filled-cell', 'correct');
          cell.dataset.coasterId = solutionCoaster.id;
        }
      });
      
      // Display results
      resultsMessage.style.display = 'block';
      resultsMessage.textContent = `Game over! You had ${correctCells.length} correct answers out of 9 cells.`;
      resultsMessage.className = 'check-results success';
      
      // Disable cell clicks after game is ended
      document.querySelectorAll('.cell.input-cell').forEach(cell => {
        cell.onclick = null;
        cell.classList.remove('input-cell');
      });
    }
    
    // Event listeners
    coasterSearchBox.addEventListener('input', findCoasters);
    
    selectButton.addEventListener('click', () => {
      if (currentCell && selectedCoaster) {
        // Display coaster name and park
        currentCell.innerHTML = `
          <div>${selectedCoaster.name}</div>
          <div class="park-name">${selectedCoaster.park}</div>
        `;
        currentCell.classList.add('filled-cell');
        
        // Store coaster data
        currentCell.dataset.coasterId = selectedCoaster.id;
        
        // Update game grid
        const row = parseInt(currentCell.dataset.row);
        const col = parseInt(currentCell.dataset.col);
        gameGrid[row][col] = selectedCoaster;
        
        closeSearchModal();
      }
    });
    
    // Close modal if clicking outside of it
    window.addEventListener('click', (event) => {
      if (event.target === searchModal) {
        closeSearchModal();
      }
    });
    
    // Close search results if clicking outside
    document.addEventListener('click', (event) => {
      if (!event.target.closest('.search-container')) {
        searchList.classList.add('hide-search-list');
      }
    });
    
    // Allow pressing Enter to search
    coasterSearchBox.addEventListener('keypress', (event) => {
      if (event.key === 'Enter' && selectedCoaster) {
        selectButton.click();
      }
    });
    
    // Start the game by loading coaster data
    window.onload = loadCoasterData;
  </script>
</body>
</html>
