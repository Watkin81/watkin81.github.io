<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Coaster Grid</title>
  <style>
    body { 
      font-family: sans-serif; 
      text-align: center; 
      background: #f5f5f5; 
      margin: 0;
      padding: 20px;
    }
    .grid-container {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(4, 1fr);
      gap: 5px; 
      margin: 20px auto; 
      width: 80vw; 
      max-width: 600px;
    }
    .cell {
      border: 1px solid #ccc; 
      padding: 10px; 
      min-height: 60px; 
      background: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 14px;
    }
    .header { 
      font-weight: bold; 
      background-color: #e0e0e0; 
    }
    .input-cell { 
      cursor: pointer; 
    }
    .input-cell:hover { 
      background: #f0f0f0; 
    }
    .filled-cell {
      background-color: #e6f7ff;
    }
    .park-name {
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }
    .correct {
      background-color: #b7eb8f;
    }
    .incorrect {
      background-color: #ffccc7;
    }
    
    /* Search Modal Styles */
    .search-modal {
      display: none;
      position: fixed;
      z-index: 100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }
    
    .search-content {
      background-color: white;
      margin: 10% auto;
      padding: 20px;
      border-radius: 8px;
      width: 80%;
      max-width: 500px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    .search-container {
      position: relative;
      width: 100%;
    }
    
    #coasterSearchBox {
      width: 100%;
      padding: 12px;
      font-size: 16px;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
      margin-bottom: 10px;
    }
    
    .search-list {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
    }
    
    .search-list .search-item {
      padding: 10px;
      cursor: pointer;
      text-align: left;
      border-bottom: 1px solid #eee;
    }
    
    .search-list .search-item:hover {
      background-color: #f0f0f0;
    }
    
    .hide-search-list {
      display: none;
    }
    
    .search-item-details {
      font-size: 0.8em;
      color: #666;
    }
    
    .selected-coaster {
      background-color: #e6f7ff;
      border-left: 3px solid #1890ff;
    }
    
    .modal-buttons {
      margin-top: 15px;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    
    .modal-button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .cancel-button {
      background-color: #f5f5f5;
      color: #333;
    }
    
    .select-button {
      background-color: #1890ff;
      color: white;
    }
    
    .select-button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    
    .game-controls {
      margin: 20px auto;
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    
    .game-button {
      padding: 10px 20px;
      background-color: #1890ff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .game-button:hover {
      background-color: #40a9ff;
    }
    
    .game-button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    
    .check-results {
      margin-top: 20px;
      padding: 10px;
      border-radius: 4px;
      display: none;
    }
    
    .success {
      background-color: #f6ffed;
      border: 1px solid #b7eb8f;
      color: #52c41a;
    }
    
    .failure {
      background-color: #fff2f0;
      border: 1px solid #ffccc7;
      color: #ff4d4f;
    }
    
    .loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 200px;
    }
    
    .loading-spinner {
      border: 6px solid #f3f3f3;
      border-top: 6px solid #3498db;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    
    .criteria-info {
      font-size: 12px;
      margin-top: 5px;
      color: #666;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <h1>Coaster Grid</h1>
  <p>Fill the grid with roller coasters that match the criteria for both the row and column.</p>

  <div class="game-controls">
    <button class="game-button" id="newGameBtn">New Game</button>
    <button class="game-button" id="endGameBtn">End Game</button>
  </div>

  <div id="loadingContainer" class="loading">
    <div class="loading-spinner"></div>
    <div>Loading coaster data...</div>
  </div>

  <div class="grid-container" id="coasterGrid" style="display: none;">
    <!-- Grid will be generated dynamically -->
  </div>

  <div id="resultsMessage" class="check-results"></div>

  <!-- Search Modal -->
  <div id="searchModal" class="search-modal">
    <div class="search-content">
      <h2>Select a Coaster...</h2>
      <div class="search-container">
        <input type="text" id="coasterSearchBox" placeholder="Type coaster name...">
        <div class="search-list hide-search-list" id="searchList">
          <!-- Search results will be added here -->
        </div>
      </div>
      <div class="modal-buttons">
        <button class="modal-button cancel-button" onclick="closeSearchModal()">Cancel</button>
        <button class="modal-button select-button" id="selectButton" disabled>Select</button>
      </div>
    </div>
  </div>

  <script>
    // Game variables
    let currentCell = null;
    let debounce = null;
    let selectedCoaster = null;
    let gameGrid = [];
    let solution = [];
    let rowCriteria = [];
    let colCriteria = [];
    let allCoasters = [];
    
    // DOM elements
    const searchModal = document.getElementById('searchModal');
    const coasterSearchBox = document.getElementById('coasterSearchBox');
    const searchList = document.getElementById('searchList');
    const selectButton = document.getElementById('selectButton');
    const coasterGrid = document.getElementById('coasterGrid');
    const newGameBtn = document.getElementById('newGameBtn');
    const endGameBtn = document.getElementById('endGameBtn');
    const resultsMessage = document.getElementById('resultsMessage');
    const loadingContainer = document.getElementById('loadingContainer');
    
    // Load coaster data
    async function loadCoasterData() {
      try {
        // Replace with the path to your JSON file
        const response = await fetch('coasterData.json');
        if (!response.ok) {
          throw new Error('Failed to load coaster data');
        }
        
        const data = await response.json();
        
        // Process and filter the data
        if (data && data.coasters && data.coasters.length > 0) {
          // Filter out coasters with missing essential data
          allCoasters = data.coasters.filter(coaster => {
            return coaster.name && 
                   coaster.park && 
                   coaster.details && 
                   coaster.details.manufacturer;
          }).map(coaster => {
            // Normalize the data structure
            return {
              id: coaster.id,
              name: coaster.name,
              park: coaster.park,
              manufacturer: coaster.details.manufacturer || '',
              height: parseFloat(coaster.stats?.height) || 0,
              length: parseFloat(coaster.stats?.length) || 0,
              speed: parseFloat(coaster.stats?.speed) || 0,
              inversions: parseInt(coaster.stats?.inversions) || 0,
              angle: parseFloat(coaster.stats?.angle) || 0,
              year: coaster.status?.opened ? parseInt(coaster.status.opened.split('-')[0]) : 0,
              location: coaster.location || {},
              type: coaster.details.type || '',
              design: coaster.details.design || '',
              trackLayout: coaster.details.layout || '',
              category: coaster.details.category || '',
              elements: coaster.details.elements || []
            };
          });
          
          console.log(`Loaded ${allCoasters.length} coasters`);
          
          // Hide loading indicator and show grid
          loadingContainer.style.display = 'none';
          coasterGrid.style.display = 'grid';
          
          // Initialize game
          initGame();
        } else {
          throw new Error('No coaster data found');
        }
      } catch (error) {
        console.error('Error loading coaster data:', error);
        loadingContainer.innerHTML = `
          <div>Error loading coaster data: ${error.message}</div>
          <button class="game-button" onclick="location.reload()">Retry</button>
        `;
      }
    }
    
    // Initialize game
    function initGame() {
      newGameBtn.addEventListener('click', createNewGame);
      endGameBtn.addEventListener('click', endGame);
      
      createNewGame();
    }
    
    function createNewGame() {
      // Clear any existing game state
      solution = [];
      gameGrid = Array(3).fill().map(() => Array(3).fill(null));
      resultsMessage.style.display = 'none';
      
      // Reset cell styles if there were any from previous game
      document.querySelectorAll('.cell.input-cell').forEach(cell => {
        cell.classList.remove('correct', 'incorrect', 'filled-cell');
        cell.innerHTML = '';
        cell.dataset.coasterId = '';
      });
      
      // Generate puzzle solution and criteria
      generatePuzzle();
      
      // Generate grid UI
      renderGrid();
      
      // Re-enable cell clicks if they were disabled
      document.querySelectorAll('.cell.input-cell').forEach(cell => {
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        cell.onclick = function() { handleCellClick(this, row, col); };
      });
    }
    
    // Define criteria options
    const criteriaOptions = [
      {
        type: "manufacturer",
        values: ["Bolliger & Mabillard", "Intamin", "Rocky Mountain Construction", "Vekoma", "Arrow Dynamics", "Gerstlauer", "Mack Rides"],
        matcher: function(coaster, value) {
          return coaster.manufacturer && coaster.manufacturer.includes(value);
        }
      },
      {
        type: "height",
        values: ["< 100ft", "100-150ft", "150-200ft", "> 200ft"],
        matcher: function(coaster, value) {
          const height = parseFloat(coaster.height) || 0;
          if (value === "< 100ft") return height > 0 && height < 100;
          if (value === "100-150ft") return height >= 100 && height <= 150;
          if (value === "150-200ft") return height >= 150 && height <= 200;
          if (value === "> 200ft") return height > 200;
          return false;
        }
      },
      {
        type: "length",
        values: ["< 2000ft", "2000-3000ft", "3000-4000ft", "> 4000ft"],
        matcher: function(coaster, value) {
          const length = parseFloat(coaster.length) || 0;
          if (value === "< 2000ft") return length > 0 && length < 2000;
          if (value === "2000-3000ft") return length >= 2000 && length <= 3000;
          if (value === "3000-4000ft") return length >= 3000 && length <= 4000;
          if (value === "> 4000ft") return length > 4000;
          return false;
        }
      },
      {
        type: "speed",
        values: ["< 40mph", "40-60mph", "60-80mph", "> 80mph"],
        matcher: function(coaster, value) {
          const speed = parseFloat(coaster.speed) || 0;
          if (value === "< 40mph") return speed > 0 && speed < 40;
          if (value === "40-60mph") return speed >= 40 && speed <= 60;
          if (value === "60-80mph") return speed >= 60 && speed <= 80;
          if (value === "> 80mph") return speed > 80;
          return false;
        }
      },
      {
        type: "angle",
        values: ["< 60°", "60-90°", "> 90°"],
        matcher: function(coaster, value) {
          const angle = parseFloat(coaster.angle) || 0;
          if (value === "< 60°") return angle > 0 && angle <= 60;
          if (value === "60-90°") return angle >= 60 && angle <= 90;
          if (value === "> 90°") return angle > 90;
          return false;
        }
      },
      {
        type: "inversions",
        values: ["0", "1-2", "3-5", "6+"],
        matcher: function(coaster, value) {
          const inversions = parseInt(coaster.inversions) || 0;
          if (value === "0") return inversions === 0;
          if (value === "1-2") return inversions >= 1 && inversions <= 2;
          if (value === "3-5") return inversions >= 3 && inversions <= 5;
          if (value === "6+") return inversions >= 6;
          return false;
        }
      },
      {
        type: "year",
        values: ["Pre-1990", "1990-2000", "2000-2010", "2010-2020", "2020+"],
        matcher: function(coaster, value) {
          const year = parseInt(coaster.year) || 0;
          if (value === "Pre-1990") return year > 0 && year < 1990;
          if (value === "1990-2000") return year >= 1990 && year <= 2000;
          if (value === "2000-2010") return year >= 2000 && year <= 2010;
          if (value === "2010-2020") return year >= 2010 && year <= 2020;
          if (value === "2020+") return year >= 2020;
          return false;
        }
      },
      {
        type: "coaster type",
        values: ["Steel", "Wooden", "Hybrid"],
        matcher: function(coaster, value) {
          if (!coaster.type) return false;
          const type = coaster.type.toLowerCase();
          if (value === "Steel") return type.includes("steel");
          if (value === "Wooden") return type.includes("wood");
          if (value === "Hybrid") return type.includes("hybrid") || (type.includes("wood") && type.includes("steel"));
          return false;
        }
      },
      {
        type: "design",
        values: ["Inverted", "Stand-Up", "Flying", "Sitting", "Suspended"],
        matcher: function(coaster, value) {
          if (!coaster.design) return false;
          const design = coaster.design.toLowerCase();
          return design.includes(value.toLowerCase());
        }
      },
      {
        type: "track layout",
        values: ["Out & Back", "Twister", "Wild Mouse", "Launched"],
        matcher: function(coaster, value) {
          if (!coaster.trackLayout) return false;
          const layout = coaster.trackLayout.toLowerCase();
          return layout.includes(value.toLowerCase());
        }
      },
      {
        type: "category",
        values: ["Single Rail", "Wing Coaster"],
        matcher: function(coaster, value) {
          if (!coaster.category) return false;
          const category = coaster.category.toLowerCase();
          return category.includes(value.toLowerCase());
        }
      },
      {
        type: "element",
        values: ["Loop", "Corkscrew", "Zero-G Roll"],
        matcher: function(coaster, value) {
          if (!coaster.elements || !Array.isArray(coaster.elements)) return false;
          return coaster.elements.some(element => 
            element.toLowerCase().includes(value.toLowerCase())
          );
        }
      },
      {
        type: "country",
        values: ["USA", "UK", "Germany", "Japan", "China"],
        matcher: function(coaster, value) {
          if (!coaster.location || !coaster.location.country) return false;
          const country = coaster.location.country.toLowerCase();
          if (value === "USA") return country.includes("united states") || country === "usa" || country === "us";
          if (value === "UK") return country.includes("united kingdom") || country === "uk" || country === "great britain";
          return country.includes(value.toLowerCase());
        }
      },
      {
        type: "name starts with",
        values: ["A-F", "G-M", "N-S", "T-Z"],
        matcher: function(coaster, value) {
          if (!coaster.name) return false;
          const firstLetter = coaster.name.charAt(0).toUpperCase();
          if (value === "A-F") return firstLetter >= 'A' && firstLetter <= 'F';
          if (value === "G-M") return firstLetter >= 'G' && firstLetter <= 'M';
          if (value === "N-S") return firstLetter >= 'N' && firstLetter <= 'S';
          if (value === "T-Z") return firstLetter >= 'T' && firstLetter <= 'Z';
          return false;
        }
      }
    ];
    
    function generatePuzzle() {
      let maxAttempts = 30;
      let attempts = 0;
      let success = false;
      
      while (!success && attempts < maxAttempts) {
        attempts++;
        solution = [];
        
        // Shuffle criteria options
        const shuffledOptions = [...criteriaOptions].sort(() => 0.5 - Math.random());
        
        // Select different criteria types for each row and column
        let rowCriteriaTypes = shuffledOptions.slice(0, 3);
        let colCriteriaTypes = shuffledOptions.slice(3, 6);
        
        // If we don't have enough criteria types, reuse some
        if (shuffledOptions.length < 6) {
          for (let i = rowCriteriaTypes.length; i < 3; i++) {
            rowCriteriaTypes.push(shuffledOptions[i % shuffledOptions.length]);
          }
          
          for (let i = colCriteriaTypes.length; i < 3; i++) {
            colCriteriaTypes.push(shuffledOptions[(i + 3) % shuffledOptions.length]);
          }
        }
        
        // Initialize row and column criteria arrays
        rowCriteria = [];
        colCriteria = [];
        
        // For each row, select a value from its criteria type
        for (let i = 0; i < 3; i++) {
          const criteriaType = rowCriteriaTypes[i];
          const value = criteriaType.values[Math.floor(Math.random() * criteriaType.values.length)];
          rowCriteria.push({ 
            type: criteriaType.type, 
            value, 
            matcher: criteriaType.matcher 
          });
        }
        
        // For each column, select a value from its criteria type
        for (let i = 0; i < 3; i++) {
          const criteriaType = colCriteriaTypes[i];
          const value = criteriaType.values[Math.floor(Math.random() * criteriaType.values.length)];
          colCriteria.push({ 
            type: criteriaType.type, 
            value, 
            matcher: criteriaType.matcher 
          });
        }
        
        // Check if all cells have at least one matching coaster
        let cellSolutions = [];
        let validCellCount = 0;
        
        for (let row = 0; row < 3; row++) {
          for (let col = 0; col < 3; col++) {
            const matchingCoasters = allCoasters.filter(coaster => 
              rowCriteria[row].matcher(coaster, rowCriteria[row].value) && 
              colCriteria[col].matcher(coaster, colCriteria[col].value)
            );
            
            if (matchingCoasters.length > 0) {
              validCellCount++;
              cellSolutions.push({
                row,
                col,
                possibleCoasters: matchingCoasters,
                selectedCoaster: matchingCoasters[Math.floor(Math.random() * matchingCoasters.length)]
              });
            }
          }
        }
        
        // Only consider the puzzle valid if all 9 cells have at least one valid coaster
        if (validCellCount === 9) {
          success = true;
          solution = cellSolutions;
          console.log("Valid puzzle generated after", attempts, "attempts");
          break; // Exit the loop if we found a valid solution
        }
      }
      
      // If we couldn't generate a valid puzzle after max attempts, create a fallback
      if (!success) {
        console.warn(`Could not generate complete puzzle after ${maxAttempts} attempts. Using fallback.`);
        
        // Create simple criteria that are likely to have matches
        rowCriteria = [
          { type: "coaster type", value: "Steel", matcher: criteriaOptions.find(c => c.type === "coaster type").matcher },
          { type: "coaster type", value: "Wooden", matcher: criteriaOptions.find(c => c.type === "coaster type").matcher },
          { type: "manufacturer", value: "Bolliger & Mabillard", matcher: criteriaOptions.find(c => c.type === "manufacturer").matcher }
        ];
        
        colCriteria = [
          { type: "inversions", value: "0", matcher: criteriaOptions.find(c => c.type === "inversions").matcher },
          { type: "inversions", value: "1-2", matcher: criteriaOptions.find(c => c.type === "inversions").matcher },
          { type: "inversions", value: "3-5", matcher: criteriaOptions.find(c => c.type === "inversions").matcher }
        ];
        
        // Regenerate solution with these more lenient criteria
        solution = [];
        
        for (let row = 0; row < 3; row++) {
          for (let col = 0; col < 3; col++) {
            const matchingCoasters = allCoasters.filter(coaster => 
              rowCriteria[row].matcher(coaster, rowCriteria[row].value) && 
              colCriteria[col].matcher(coaster, colCriteria[col].value)
            );
            
            if (matchingCoasters.length > 0) {
              solution.push({
                row,
                col,
                possibleCoasters: matchingCoasters,
                selectedCoaster: matchingCoasters[Math.floor(Math.random() * matchingCoasters.length)]
              });
            }
          }
        }
      }
      
      return solution.length > 0;
    }
    
    function isCoasterValidForCell(coaster, row, col) {
      if (!coaster) return false;
      
      const rowCheck = rowCriteria[row].matcher(coaster, rowCriteria[row].value);
      const colCheck = colCriteria[col].matcher(coaster, colCriteria[col].value);
      
      return rowCheck && colCheck;
    }
    
    function renderGrid() {
      // Clear existing grid
      coasterGrid.innerHTML = '';
      
      // Add blank corner cell
      const cornerCell = document.createElement('div');
      cornerCell.className = 'cell header';
      cornerCell.innerHTML = '<small>🎢</small>';
      coasterGrid.appendChild(cornerCell);
      
      // Add column headers
      for (let col = 0; col < 3; col++) {
        const colHeader = document.createElement('div');
        colHeader.className = 'cell header';
        colHeader.innerHTML = `
          <div>${colCriteria[col].value}</div>
          <div class="criteria-info">${colCriteria[col].type}</div>
        `;
        coasterGrid.appendChild(colHeader);
      }
      
      // Add rows (headers + cells)
      for (let row = 0; row < 3; row++) {
        // Add row header
        const rowHeader = document.createElement('div');
        rowHeader.className = 'cell header';
        rowHeader.innerHTML = `
          <div>${rowCriteria[row].value}</div>
          <div class="criteria-info">${rowCriteria[row].type}</div>
        `;
        coasterGrid.appendChild(rowHeader);
        
        // Add cells
        for (let col = 0; col < 3; col++) {
          const cell = document.createElement('div');
          cell.className = 'cell input-cell';
          cell.onclick = function() { handleCellClick(this, row, col); };
          cell.dataset.row = row;
          cell.dataset.col = col;
          coasterGrid.appendChild(cell);
        }
      }
    }
    
    function handleCellClick(cell, row, col) {
      currentCell = cell;
      
      // Clear previous search inputs and results
      coasterSearchBox.value = '';
      searchList.innerHTML = '';
      searchList.classList.add('hide-search-list');
      selectedCoaster = null;
      selectButton.disabled = true;
      
      // Show the search modal
      searchModal.style.display = 'block';
      
      // Focus on the search box
      setTimeout(() => coasterSearchBox.focus(), 100);
    }
    
    function closeSearchModal() {
      searchModal.style.display = 'none';
      currentCell = null;
    }
    
    function findCoasters() {
      let query = coasterSearchBox.value.trim().toLowerCase();
      if(query.length > 0) {
        searchList.classList.remove('hide-search-list');
        clearTimeout(debounce);
        debounce = setTimeout(function() {
          // Search locally in our loaded coaster data
          const results = allCoasters.filter(coaster => 
            coaster.name.toLowerCase().includes(query) ||
            coaster.park.toLowerCase().includes(query)
          ).slice(0, 50);
          
          displaySearchResults(results);
        }, 300);
      } else {
        searchList.classList.add('hide-search-list');
        selectedCoaster = null;
        selectButton.disabled = true;
      }
    }
    
    function displaySearchResults(results) {
      searchList.innerHTML = '';
      
      if (results.length > 0) {
        results.forEach(coaster => {
          const searchItem = document.createElement('div');
          searchItem.classList.add('search-item');
          
          // Get location information
          let location = '';
          if (coaster.location) {
            if (coaster.location.city) location += coaster.location.city;
            if (coaster.location.state) location += location ? `, ${coaster.location.state}` : coaster.location.state;
            if (coaster.location.country && location.indexOf(coaster.location.country) === -1) 
              location += location ? `, ${coaster.location.country}` : coaster.location.country;
          }
          
          // Display search result
          searchItem.innerHTML = `
            <div><strong>${coaster.name}</strong></div>
            <div class="search-item-details">${coaster.park}${location ? ` - ${location}` : ''}</div>
          `;
          
          searchItem.addEventListener('click', () => {
            // Remove selected class from all items
            document.querySelectorAll('.search-item').forEach(item => {
              item.classList.remove('selected-coaster');
            });
            
            // Add selected class to this item
            searchItem.classList.add('selected-coaster');
            
            // Store selected coaster data
            selectedCoaster = coaster;
            
            // Enable select button
            selectButton.disabled = false;
          });
          
          searchList.appendChild(searchItem);
        });
        
        // Show the number of results found
        const resultsCount = document.createElement('div');
        resultsCount.classList.add('search-item-details');
        resultsCount.style.padding = '5px 10px';
        resultsCount.textContent = `Showing ${results.length} results${results.length === 50 ? ' (max 50)' : ''}`;
        searchList.appendChild(resultsCount);
        
      } else {
        searchList.innerHTML = '<div class="search-item">No coasters found</div>';
      }
    }
  // Select the coaster for the current cell
selectButton.addEventListener('click', function() {
  if (currentCell && selectedCoaster) {
    // Get row and column from current cell
    const row = parseInt(currentCell.dataset.row);
    const col = parseInt(currentCell.dataset.col);
    
    // Update game grid
    gameGrid[row][col] = selectedCoaster;
    
    // Update display
    currentCell.innerHTML = `
      <div>${selectedCoaster.name}</div>
      <div class="park-name">${selectedCoaster.park}</div>
    `;
    currentCell.classList.add('filled-cell');
    currentCell.dataset.coasterId = selectedCoaster.id;
    
    // Close the modal
    closeSearchModal();
  }
});

// Add event listeners to search box
coasterSearchBox.addEventListener('input', findCoasters);
coasterSearchBox.addEventListener('focus', findCoasters);

// End game and check results
function endGame() {
  const cells = document.querySelectorAll('.cell.input-cell');
  let correctCount = 0;
  
  for (let i = 0; i < cells.length; i++) {
    const cell = cells[i];
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);
    const coasterId = cell.dataset.coasterId;
    
    if (coasterId) {
      const coaster = allCoasters.find(c => c.id === coasterId);
      if (coaster && isCoasterValidForCell(coaster, row, col)) {
        cell.classList.add('correct');
        correctCount++;
      } else {
        cell.classList.add('incorrect');
      }
    }
  }
  
  // Display results
  resultsMessage.style.display = 'block';
  if (correctCount === 9) {
    resultsMessage.className = 'check-results success';
    resultsMessage.textContent = 'Congratulations! You completed the grid correctly!';
  } else {
    resultsMessage.className = 'check-results failure';
    resultsMessage.textContent = `You got ${correctCount} out of 9 cells correct.`;
  }
  
  // Disable cell clicks once game has ended
  cells.forEach(cell => {
    cell.onclick = null;
  });
}

// Start loading coaster data when page loads
window.addEventListener('DOMContentLoaded', loadCoasterData);
