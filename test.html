<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Coaster Grid</title>
  <style>
    body { 
      font-family: sans-serif; 
      text-align: center; 
      background: #f5f5f5; 
      margin: 0;
      padding: 20px;
    }
    .grid-container {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(4, 1fr);
      gap: 5px; 
      margin: 20px auto; 
      width: 80vw; 
      max-width: 600px;
    }
    .cell {
      border: 1px solid #ccc; 
      padding: 10px; 
      min-height: 60px; 
      background: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 14px;
    }
    .header { 
      font-weight: bold; 
      background-color: #e0e0e0; 
    }
    .input-cell { 
      cursor: pointer; 
    }
    .input-cell:hover { 
      background: #f0f0f0; 
    }
    .filled-cell {
      background-color: #e6f7ff;
    }
    .park-name {
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }
    .correct {
      background-color: #b7eb8f;
    }
    .incorrect {
      background-color: #ffccc7;
    }
    
    /* Search Modal Styles */
    .search-modal {
      display: none;
      position: fixed;
      z-index: 100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }
    
    .search-content {
      background-color: white;
      margin: 10% auto;
      padding: 20px;
      border-radius: 8px;
      width: 80%;
      max-width: 500px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    .search-container {
      position: relative;
      width: 100%;
    }
    
    #coasterSearchBox {
      width: 100%;
      padding: 12px;
      font-size: 16px;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
      margin-bottom: 10px;
    }
    
    .search-list {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
    }
    
    .search-list .search-item {
      padding: 10px;
      cursor: pointer;
      text-align: left;
      border-bottom: 1px solid #eee;
    }
    
    .search-list .search-item:hover {
      background-color: #f0f0f0;
    }
    
    .hide-search-list {
      display: none;
    }
    
    .search-item-details {
      font-size: 0.8em;
      color: #666;
    }
    
    .selected-coaster {
      background-color: #e6f7ff;
      border-left: 3px solid #1890ff;
    }
    
    .modal-buttons {
      margin-top: 15px;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    
    .modal-button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .cancel-button {
      background-color: #f5f5f5;
      color: #333;
    }
    
    .select-button {
      background-color: #1890ff;
      color: white;
    }
    
    .select-button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    
    .game-controls {
      margin: 20px auto;
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    
    .game-button {
      padding: 10px 20px;
      background-color: #1890ff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .game-button:hover {
      background-color: #40a9ff;
    }
    
    .game-button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    
    .check-results {
      margin-top: 20px;
      padding: 10px;
      border-radius: 4px;
      display: none;
    }
    
    .success {
      background-color: #f6ffed;
      border: 1px solid #b7eb8f;
      color: #52c41a;
    }
    
    .failure {
      background-color: #fff2f0;
      border: 1px solid #ffccc7;
      color: #ff4d4f;
    }
    
    .loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 200px;
    }
    
    .loading-spinner {
      border: 6px solid #f3f3f3;
      border-top: 6px solid #3498db;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    
    .criteria-info {
      font-size: 12px;
      margin-top: 5px;
      color: #666;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <h1>Coaster Grid Game</h1>
  <p>Fill the grid with roller coasters that match the criteria for both the row and column!</p>

  <div class="game-controls">
    <button class="game-button" id="newGameBtn">New Game</button>
    <button class="game-button" id="endGameBtn">End Game</button>
  </div>

  <div id="loadingContainer" class="loading">
    <div class="loading-spinner"></div>
    <div>Loading coaster data...</div>
  </div>

  <div class="grid-container" id="coasterGrid" style="display: none;">
    <!-- Grid will be generated dynamically -->
  </div>

  <div id="resultsMessage" class="check-results"></div>

  <!-- Search Modal -->
  <div id="searchModal" class="search-modal">
    <div class="search-content">
      <h2>Select a Coaster...</h2>
      <div class="search-container">
        <input type="text" id="coasterSearchBox" placeholder="Type coaster name...">
        <div class="search-list hide-search-list" id="searchList">
          <!-- Search results will be added here -->
        </div>
      </div>
      <div class="modal-buttons">
        <button class="modal-button cancel-button" onclick="closeSearchModal()">Cancel</button>
        <button class="modal-button select-button" id="selectButton" disabled>Select</button>
      </div>
    </div>
  </div>

  <script>
    // Game variables
    let currentCell = null;
    let debounce = null;
    let selectedCoaster = null;
    let gameGrid = [];
    let solution = [];
    let rowCriteria = [];
    let colCriteria = [];
    let allCoasters = [];
    
    // DOM elements
    const searchModal = document.getElementById('searchModal');
    const coasterSearchBox = document.getElementById('coasterSearchBox');
    const searchList = document.getElementById('searchList');
    const selectButton = document.getElementById('selectButton');
    const coasterGrid = document.getElementById('coasterGrid');
    const newGameBtn = document.getElementById('newGameBtn');
    const endGameBtn = document.getElementById('endGameBtn');
    const resultsMessage = document.getElementById('resultsMessage');
    const loadingContainer = document.getElementById('loadingContainer');
    
    // Load coaster data
    async function loadCoasterData() {
      try {
        // Replace with the path to your JSON file
        const response = await fetch('coasterData.json');
        if (!response.ok) {
          throw new Error('Failed to load coaster data');
        }
        
        const data = await response.json();
        
        // Process and filter the data
        if (data && data.coasters && data.coasters.length > 0) {
          // Filter out coasters with missing essential data
          allCoasters = data.coasters.filter(coaster => {
            return coaster.name && 
                   coaster.park && 
                   coaster.details && 
                   coaster.details.manufacturer &&
                   coaster.stats &&
                   (coaster.stats.height || coaster.stats.inversions || coaster.status.opened);
          }).map(coaster => {
            // Normalize the data structure
            return {
              id: coaster.id,
              name: coaster.name,
              park: coaster.park,
              manufacturer: coaster.details.manufacturer,
              height: parseFloat(coaster.stats.height) || 0,
              inversions: parseInt(coaster.stats.inversions) || 0,
              year: coaster.status.opened ? parseInt(coaster.status.opened.split('-')[0]) : 0,
              location: coaster.location,
              type: coaster.details.type || ''
            };
          });
          
          console.log(`Loaded ${allCoasters.length} coasters`);
          
          // Hide loading indicator and show grid
          loadingContainer.style.display = 'none';
          coasterGrid.style.display = 'grid';
          
          // Initialize game
          initGame();
        } else {
          throw new Error('No coaster data found');
        }
      } catch (error) {
        console.error('Error loading coaster data:', error);
        loadingContainer.innerHTML = `
          <div>Error loading coaster data: ${error.message}</div>
          <button class="game-button" onclick="location.reload()">Retry</button>
        `;
      }
    }
    
    // Initialize game
    function initGame() {
      newGameBtn.addEventListener('click', createNewGame);
      endGameBtn.addEventListener('click', endGame);
      
      createNewGame();
    }
    
    function createNewGame() {
      // Clear any existing game state
      solution = [];
      gameGrid = Array(3).fill().map(() => Array(3).fill(null));
      resultsMessage.style.display = 'none';
      
      // Generate puzzle solution and criteria
      generatePuzzle();
      
      // Generate grid UI
      renderGrid();
    }
    
    // Define criteria options
    const criteriaOptions = [
      {
        type: "manufacturer",
        values: ["Bolliger & Mabillard", "Intamin", "Rocky Mountain Construction", "Vekoma", "Arrow Dynamics"],
        matcher: function(coaster, value) {
          return coaster.manufacturer && coaster.manufacturer.includes(value);
        }
      },
      {
        type: "height",
        values: ["< 100ft", "100-200ft", "> 200ft"],
        matcher: function(coaster, value) {
          const height = parseFloat(coaster.height) || 0;
          if (value === "< 100ft") return height > 0 && height < 100;
          if (value === "100-200ft") return height >= 100 && height <= 200;
          if (value === "> 200ft") return height > 200;
          return false;
        }
      },
      {
        type: "inversions",
        values: ["0", "1-3", "4+"],
        matcher: function(coaster, value) {
          const inversions = parseInt(coaster.inversions) || 0;
          if (value === "0") return inversions === 0;
          if (value === "1-3") return inversions >= 1 && inversions <= 3;
          if (value === "4+") return inversions >= 4;
          return false;
        }
      },
      {
        type: "year",
        values: ["Pre-2000", "2000-2010", "2010+"],
        matcher: function(coaster, value) {
          const year = parseInt(coaster.year) || 0;
          if (value === "Pre-2000") return year > 0 && year < 2000;
          if (value === "2000-2010") return year >= 2000 && year <= 2010;
          if (value === "2010+") return year > 2010;
          return false;
        }
      },
      {
        type: "coaster type",
        values: ["Steel", "Wooden", "Hybrid"],
        matcher: function(coaster, value) {
          if (!coaster.type) return false;
          const type = coaster.type.toLowerCase();
          if (value === "Steel") return type.includes("steel");
          if (value === "Wooden") return type.includes("wood");
          if (value === "Hybrid") return type.includes("hybrid") || (type.includes("wood") && type.includes("steel"));
          return false;
        }
      }
    ];
    
    function generatePuzzle() {
      let maxAttempts = 30;
      let attempts = 0;
      let success = false;
      
      while (!success && attempts < maxAttempts) {
        attempts++;
        solution = [];
        
        // Shuffle criteria options
        const shuffledOptions = [...criteriaOptions].sort(() => 0.5 - Math.random());
        
        // Select different criteria types for each row and column
        // We need 3 criteria for rows and 3 for columns, ensuring no duplicate criteria types at intersections
        let selectedCriteriaTypes = [];
        let rowCriteriaTypes = [];
        let colCriteriaTypes = [];
        
        // First attempt: try to get 3 unique criteria types for rows and 3 for columns
        // This gives us the best chance of avoiding conflicts
        if (shuffledOptions.length >= 6) {
          rowCriteriaTypes = shuffledOptions.slice(0, 3);
          colCriteriaTypes = shuffledOptions.slice(3, 6);
        } else {
          // If we don't have 6 unique criteria types, we'll need to reuse some
          // But ensure no row and column have the same criteria type
          const availableCriteria = [...shuffledOptions];
          
          // Select criteria for rows
          for (let i = 0; i < 3; i++) {
            if (availableCriteria.length > 0) {
              const criteriaIndex = Math.floor(Math.random() * availableCriteria.length);
              rowCriteriaTypes.push(availableCriteria[criteriaIndex]);
              availableCriteria.splice(criteriaIndex, 1);
            } else {
              // Reuse a criteria type, but not one already used for columns
              const unusedCriteria = shuffledOptions.filter(
                criteria => !colCriteriaTypes.includes(criteria)
              );
              if (unusedCriteria.length > 0) {
                rowCriteriaTypes.push(unusedCriteria[0]);
              } else {
                rowCriteriaTypes.push(shuffledOptions[0]);
              }
            }
          }
          
          // Select criteria for columns, avoiding types used in rows when possible
          for (let i = 0; i < 3; i++) {
            // Try to find criteria not used in rows
            const unusedCriteria = shuffledOptions.filter(
              criteria => !rowCriteriaTypes.includes(criteria)
            );
            
            if (unusedCriteria.length > 0) {
              const criteriaIndex = Math.floor(Math.random() * unusedCriteria.length);
              colCriteriaTypes.push(unusedCriteria[criteriaIndex]);
            } else {
              // If all criteria types are used in rows, pick any (but this may cause conflicts)
              colCriteriaTypes.push(shuffledOptions[i % shuffledOptions.length]);
            }
          }
        }
        
        // Initialize row and column criteria arrays
        rowCriteria = [];
        colCriteria = [];
        
        // For each row, select a value from its criteria type
        for (let i = 0; i < 3; i++) {
          const criteriaType = rowCriteriaTypes[i];
          const value = criteriaType.values[Math.floor(Math.random() * criteriaType.values.length)];
          rowCriteria.push({ 
            type: criteriaType.type, 
            value, 
            matcher: criteriaType.matcher 
          });
        }
        
        // For each column, select a value from its criteria type
        for (let i = 0; i < 3; i++) {
          const criteriaType = colCriteriaTypes[i];
          const value = criteriaType.values[Math.floor(Math.random() * criteriaType.values.length)];
          colCriteria.push({ 
            type: criteriaType.type, 
            value, 
            matcher: criteriaType.matcher 
          });
        }
        
        // Check if all cells have at least one matching coaster
        let validCount = 0;
        
        for (let row = 0; row < 3; row++) {
          for (let col = 0; col < 3; col++) {
            const matchingCoasters = allCoasters.filter(coaster => 
              rowCriteria[row].matcher(coaster, rowCriteria[row].value) && 
              colCriteria[col].matcher(coaster, colCriteria[col].value)
            );
            
            if (matchingCoasters.length > 0) {
              validCount++;
              solution.push({
                row,
                col,
                possibleCoasters: matchingCoasters,
                selectedCoaster: matchingCoasters[Math.floor(Math.random() * matchingCoasters.length)]
              });
            }
          }
        }
        
        if (validCount === 9) {
          success = true;
        }
      }
      
      if (!success) {
        console.warn(`Could not generate complete puzzle after ${maxAttempts} attempts. Using best attempt.`);
      }
      
      return success;
    }
    
    function isCoasterValidForCell(coaster, row, col) {
      const rowCheck = rowCriteria[row].matcher(coaster, rowCriteria[row].value);
      const colCheck = colCriteria[col].matcher(coaster, colCriteria[col].value);
      
      return rowCheck && colCheck;
    }
    
    function renderGrid() {
      // Clear existing grid
      coasterGrid.innerHTML = '';
      
      // Add blank corner cell
      const cornerCell = document.createElement('div');
      cornerCell.className = 'cell header';
      cornerCell.innerHTML = '<small>ðŸŽ¢</small>';
      coasterGrid.appendChild(cornerCell);
      
      // Add column headers
      for (let col = 0; col < 3; col++) {
        const colHeader = document.createElement('div');
        colHeader.className = 'cell header';
        colHeader.innerHTML = `
          <div>${colCriteria[col].value}</div>
          <div class="criteria-info">${colCriteria[col].type}</div>
        `;
        coasterGrid.appendChild(colHeader);
      }
      
      // Add rows (headers + cells)
      for (let row = 0; row < 3; row++) {
        // Add row header
        const rowHeader = document.createElement('div');
        rowHeader.className = 'cell header';
        rowHeader.innerHTML = `
          <div>${rowCriteria[row].value}</div>
          <div class="criteria-info">${rowCriteria[row].type}</div>
        `;
        coasterGrid.appendChild(rowHeader);
        
        // Add cells
        for (let col = 0; col < 3; col++) {
          const cell = document.createElement('div');
          cell.className = 'cell input-cell';
          cell.onclick = function() { handleCellClick(this, row, col); };
          cell.dataset.row = row;
          cell.dataset.col = col;
          coasterGrid.appendChild(cell);
        }
      }
    }
    
    function handleCellClick(cell, row, col) {
      currentCell = cell;
      
      // Clear previous search inputs and results
      coasterSearchBox.value = '';
      searchList.innerHTML = '';
      searchList.classList.add('hide-search-list');
      selectedCoaster = null;
      selectButton.disabled = true;
      
      // Show the search modal
      searchModal.style.display = 'block';
      
      // Focus on the search box
      setTimeout(() => coasterSearchBox.focus(), 100);
    }
    
    function closeSearchModal() {
      searchModal.style.display = 'none';
      currentCell = null;
    }
    
    function findCoasters() {
      let query = coasterSearchBox.value.trim().toLowerCase();
      if(query.length > 0) {
        searchList.classList.remove('hide-search-list');
        clearTimeout(debounce);
        debounce = setTimeout(function() {
          // Search locally in our loaded coaster data
          const results = allCoasters.filter(coaster => 
            coaster.name.toLowerCase().includes(query) ||
            coaster.park.toLowerCase().includes(query)
          ).slice(0, 20); // Limit to 20 results to prevent performance issues
          
          displaySearchResults(results);
        }, 300);
      } else {
        searchList.classList.add('hide-search-list');
        selectedCoaster = null;
        selectButton.disabled = true;
      }
    }
    
    function displaySearchResults(results) {
      searchList.innerHTML = '';
      
      if (results.length > 0) {
        results.forEach(coaster => {
          const searchItem = document.createElement('div');
          searchItem.classList.add('search-item');
          
          // Get location information
          let location = '';
          if (coaster.location) {
            if (coaster.location.city) location += coaster.location.city;
            if (coaster.location.state) location += location ? `, ${coaster.location.state}` : coaster.location.state;
            if (coaster.location.country && !location.includes(coaster.location.country)) 
              location += location ? `, ${coaster.location.country}` : coaster.location.country;
          }
          
          // Display search result
          searchItem.innerHTML = `
            <div><strong>${coaster.name}</strong></div>
            <div class="search-item-details">${coaster.park}${location ? ` - ${location}` : ''}</div>
          `;
          
          searchItem.addEventListener('click', () => {
            // Remove selected class from all items
            document.querySelectorAll('.search-item').forEach(item => {
              item.classList.remove('selected-coaster');
            });
            
            // Add selected class to this item
            searchItem.classList.add('selected-coaster');
            
            // Store selected coaster data
            selectedCoaster = coaster;
            
            // Enable select button
            selectButton.disabled = false;
          });
          
          searchList.appendChild(searchItem);
        });
      } else {
        searchList.innerHTML = '<div class="search-item">No coasters found</div>';
      }
    }
    
    function endGame() {
      if (!confirm("Are you ready to end the game and see results?")) {
        return;
      }
      
      // First check which cells are correct
      let correctCells = [];
      let emptyCells = [];
      
      document.querySelectorAll('.cell.input-cell').forEach(cell => {
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        
        if (cell.dataset.coasterId) {
          // Cell is filled, check if it's correct
          const coasterId = parseInt(cell.dataset.coasterId);
          const selectedCoaster = allCoasters.find(c => c.id === coasterId);
          
          if (selectedCoaster && isCoasterValidForCell(selectedCoaster, row, col)) {
            cell.classList.add('correct');
            correctCells.push({row, col});
          } else {
            cell.classList.add('incorrect');
            // Find solution for this cell
            const cellSolution = solution.find(s => s.row === row && s.col === col);
            if (cellSolution) {
              const solutionCoaster = cellSolution.selectedCoaster;
              
              // Display solution
              cell.innerHTML = `
                <div>${solutionCoaster.name}</div>
                <div class="park-name">${solutionCoaster.park}</div>
              `;
              cell.classList.remove('incorrect');
              cell.classList.add('filled-cell', 'correct');
              cell.dataset.coasterId = solutionCoaster.id;
            }
          }
        } else {
          // Cell is empty
          emptyCells.push({row, col});
        }
      });
      
      // Fill empty cells with solutions
      emptyCells.forEach(({row, col}) => {
        const cell = document.querySelector(`.cell.input-cell[data-row="${row}"][data-col="${col}"]`);
        const cellSolution = solution.find(s => s.row === row && s.col === col);
        
        if (cellSolution) {
          const solutionCoaster = cellSolution.selectedCoaster;
          
          // Display solution
          cell.innerHTML = `
            <div>${solutionCoaster.name}</div>
            <div class="park-name">${solutionCoaster.park}</div>
          `;
          cell.classList.add('filled-cell', 'correct');
          cell.dataset.coasterId = solutionCoaster.id;
        }
      });
      
      // Display results
      resultsMessage.style.display = 'block';
      resultsMessage.textContent = `Game over! You had ${correctCells.length} correct answers out of 9 cells.`;
      resultsMessage.className = 'check-results success';
      
      // Disable cell clicks after game is ended
      document.querySelectorAll('.cell.input-cell').forEach(cell => {
        cell.onclick = null;
        cell.classList.remove('input-cell');
      });
    }
    
    // Event listeners
    coasterSearchBox.addEventListener('input', findCoasters);
    
    selectButton.addEventListener('click', () => {
      if (currentCell && selectedCoaster) {
        // Display coaster name and park
        currentCell.innerHTML = `
          <div>${selectedCoaster.name}</div>
          <div class="park-name">${selectedCoaster.park}</div>
        `;
        currentCell.classList.add('filled-cell');
        
        // Store coaster data
        currentCell.dataset.coasterId = selectedCoaster.id;
        
        // Update game grid
        const row = parseInt(currentCell.dataset.row);
        const col = parseInt(currentCell.dataset.col);
        gameGrid[row][col] = selectedCoaster;
        
        closeSearchModal();
      }
    });
    
    // Close modal if clicking outside of it
    window.addEventListener('click', (event) => {
      if (event.target === searchModal) {
        closeSearchModal();
      }
    });
    
    // Close search results if clicking outside
    document.addEventListener('click', (event) => {
      if (!event.target.closest('.search-container')) {
        searchList.classList.add('hide-search-list');
      }
    });
    
    // Allow pressing Enter to search
    coasterSearchBox.addEventListener('keypress', (event) => {
      if (event.key === 'Enter' && selectedCoaster) {
        selectButton.click();
      }
    });
    
    // Start the game by loading coaster data
    window.onload = loadCoasterData;
  </script>
</body>
</html>
